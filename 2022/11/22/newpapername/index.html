

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/lbxx.png">
  <link rel="icon" href="/img/lbxx.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="SpringBoot2核心技术-基础入门01、基础入门-SpringBoot2课程介绍 Spring Boot 2核心技术  Spring Boot 2响应式编程    学习要求-熟悉Spring基础-熟悉Maven使用 环境要求 Java8及以上 Maven 3.3及以上   学习资料 Spring Boot官网 Spring Boot官方文档 本课程文档地址 视频地址1、视频地址2 源码地址">
<meta property="og:type" content="article">
<meta property="og:title" content="newpapername">
<meta property="og:url" content="http://example.com/2022/11/22/newpapername/index.html">
<meta property="og:site_name" content="XtwoY">
<meta property="og:description" content="SpringBoot2核心技术-基础入门01、基础入门-SpringBoot2课程介绍 Spring Boot 2核心技术  Spring Boot 2响应式编程    学习要求-熟悉Spring基础-熟悉Maven使用 环境要求 Java8及以上 Maven 3.3及以上   学习资料 Spring Boot官网 Spring Boot官方文档 本课程文档地址 视频地址1、视频地址2 源码地址">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211322434.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004250581.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211310801.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004523307.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004621290.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004733270.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004828702.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005342147.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005453173.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005536620.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211458073.jpg">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005703527.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005802305.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005926474.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010047654.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010247689.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010403920.jpg">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010509984.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211315633.png">
<meta property="og:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211315638.png">
<meta property="article:published_time" content="2022-11-22T03:29:35.000Z">
<meta property="article:modified_time" content="2022-11-22T07:32:21.303Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211322434.png">
  
  
  
  <title>newpapername - XtwoY</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":150,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>XtwoYのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="newpapername"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-22 11:29" pubdate>
          November 22, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          234k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1953 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">newpapername</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="SpringBoot2核心技术-基础入门"><a href="#SpringBoot2核心技术-基础入门" class="headerlink" title="SpringBoot2核心技术-基础入门"></a>SpringBoot2核心技术-基础入门</h1><h2 id="01、基础入门-SpringBoot2课程介绍"><a href="#01、基础入门-SpringBoot2课程介绍" class="headerlink" title="01、基础入门-SpringBoot2课程介绍"></a>01、基础入门-SpringBoot2课程介绍</h2><ol>
<li><p>Spring Boot 2核心技术</p>
</li>
<li><p>Spring Boot 2响应式编程</p>
</li>
</ol>
<ul>
<li>学习要求<br>-熟悉Spring基础<br>-熟悉Maven使用</li>
<li>环境要求<ul>
<li>Java8及以上</li>
<li>Maven 3.3及以上</li>
</ul>
</li>
<li>学习资料<ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">Spring Boot官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/">Spring Boot官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/atguigu/springboot">本课程文档地址</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gulixueyuan.com/">视频地址1</a>、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT?p=1">视频地址2</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/leifengyang/springboot2">源码地址</a></li>
</ul>
</li>
</ul>
<h2 id="02、基础入门-Spring生态圈"><a href="#02、基础入门-Spring生态圈" class="headerlink" title="02、基础入门-Spring生态圈"></a>02、基础入门-Spring生态圈</h2><p><a target="_blank" rel="noopener" href="https://spring.io/">Spring官网</a></p>
<h3 id="Spring能做什么"><a href="#Spring能做什么" class="headerlink" title="Spring能做什么"></a>Spring能做什么</h3><h4 id="Spring的能力"><a href="#Spring的能力" class="headerlink" title="Spring的能力"></a>Spring的能力</h4><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211322434.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="Spring的生态"><a href="#Spring的生态" class="headerlink" title="Spring的生态"></a>Spring的生态</h4><p>覆盖了：</p>
<ul>
<li>web开发</li>
<li>数据访问</li>
<li>安全控制</li>
<li>分布式</li>
<li>消息服务</li>
<li>移动开发</li>
<li>批处理</li>
<li>……</li>
</ul>
<h4 id="Spring5重大升级"><a href="#Spring5重大升级" class="headerlink" title="Spring5重大升级"></a>Spring5重大升级</h4><ul>
<li>响应式编程</li>
</ul>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004250581.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>内部源码设计</li>
</ul>
<p>基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。</p>
<h3 id="为什么用SpringBoot"><a href="#为什么用SpringBoot" class="headerlink" title="为什么用SpringBoot"></a>为什么用SpringBoot</h3><blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">link</a></p>
<p>能快速创建出生产级别的Spring应用。</p>
</blockquote>
<h4 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h4><ul>
<li><p>Create stand-alone Spring applications</p>
<ul>
<li>创建独立Spring应用</li>
</ul>
</li>
<li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p>
<ul>
<li>内嵌web服务器</li>
</ul>
</li>
<li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p>
<ul>
<li>自动starter依赖，简化构建配置</li>
</ul>
</li>
<li><p>Automatically configure Spring and 3rd party libraries whenever possible</p>
<ul>
<li>自动配置Spring以及第三方功能</li>
</ul>
</li>
<li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p>
<ul>
<li>提供生产级别的监控、健康检查及外部化配置</li>
</ul>
</li>
<li><p>Absolutely no code generation and no requirement for XML configuration</p>
<ul>
<li>无代码生成、无需编写XML</li>
</ul>
</li>
<li><p>SpringBoot是整合Spring技术栈的一站式框架</p>
</li>
<li><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p>
</li>
</ul>
<h4 id="SpringBoot缺点"><a href="#SpringBoot缺点" class="headerlink" title="SpringBoot缺点"></a>SpringBoot缺点</h4><ul>
<li>人称版本帝，迭代快，需要时刻关注变化</li>
<li>封装太深，内部原理复杂，不容易精通</li>
</ul>
<h2 id="03、基础入门-SpringBoot的大时代背景"><a href="#03、基础入门-SpringBoot的大时代背景" class="headerlink" title="03、基础入门-SpringBoot的大时代背景"></a>03、基础入门-SpringBoot的大时代背景</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><blockquote>
<p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are built around <strong>business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a bare minimum of centralized management of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.——<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p>
</blockquote>
<ul>
<li>微服务是一种架构风格</li>
<li>一个应用拆分为一组小型服务</li>
<li>每个服务运行在自己的进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级HTTP交互</li>
<li>服务围绕业务功能拆分</li>
<li>可以由全自动部署机制独立部署</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211310801.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="分布式的困难"><a href="#分布式的困难" class="headerlink" title="分布式的困难"></a>分布式的困难</h4><ul>
<li>远程调用</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>服务容错</li>
<li>配置管理</li>
<li>服务监控</li>
<li>链路追踪</li>
<li>日志管理</li>
<li>任务调度</li>
<li>……</li>
</ul>
<h4 id="分布式的解决"><a href="#分布式的解决" class="headerlink" title="分布式的解决"></a>分布式的解决</h4><ul>
<li>SpringBoot + SpringCloud</li>
</ul>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004523307.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>原生应用如何上云。 Cloud Native</p>
<h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a>上云的困难</h4><ul>
<li>服务自愈</li>
<li>弹性伸缩</li>
<li>服务隔离</li>
<li>自动化部署</li>
<li>灰度发布</li>
<li>流量治理</li>
<li>……</li>
</ul>
<h4 id="上云的解决"><a href="#上云的解决" class="headerlink" title="上云的解决"></a>上云的解决</h4><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004621290.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="04、基础入门-SpringBoot官方文档架构"><a href="#04、基础入门-SpringBoot官方文档架构" class="headerlink" title="04、基础入门-SpringBoot官方文档架构"></a>04、基础入门-SpringBoot官方文档架构</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">Spring Boot官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/">Spring Boot官方文档</a></li>
</ul>
<h3 id="官网文档架构"><a href="#官网文档架构" class="headerlink" title="官网文档架构"></a>官网文档架构</h3><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004733270.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205004828702.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/wiki#release-notes">查看版本新特性</a></p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005342147.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="05、基础入门-SpringBoot-HelloWorld"><a href="#05、基础入门-SpringBoot-HelloWorld" class="headerlink" title="05、基础入门-SpringBoot-HelloWorld"></a>05、基础入门-SpringBoot-HelloWorld</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><ul>
<li>Java 8</li>
<li>Maven 3.3+</li>
<li>IntelliJ IDEA 2019.1.2</li>
</ul>
<h4 id="Maven配置文件"><a href="#Maven配置文件" class="headerlink" title="Maven配置文件"></a>Maven配置文件</h4><p>新添内容：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mirrors&gt;
	&lt;mirror&gt;
		&lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;
		&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;
		&lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;
		&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;
	&lt;&#x2F;mirror&gt;
&lt;&#x2F;mirrors&gt;

&lt;profiles&gt;
	&lt;profile&gt;
		&lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;

		&lt;activation&gt;
			&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;
			&lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;
		&lt;&#x2F;activation&gt;

		&lt;properties&gt;
			&lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;
			&lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;
			&lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;
		&lt;&#x2F;properties&gt;
	&lt;&#x2F;profile&gt;
&lt;&#x2F;profiles&gt;</code></pre>

<h3 id="HelloWorld项目"><a href="#HelloWorld项目" class="headerlink" title="HelloWorld项目"></a>HelloWorld项目</h3><p>需求：浏览发送&#x2F;hello请求，响应 “Hello，Spring Boot 2”</p>
<h4 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h4><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
	&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
&lt;&#x2F;parent&gt;

&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;
	&lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;</code></pre>

<h4 id="创建主程序"><a href="#创建主程序" class="headerlink" title="创建主程序"></a>创建主程序</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class, args);
    &#125;
&#125;
</code></pre>

<h4 id="编写业务"><a href="#编写业务" class="headerlink" title="编写业务"></a>编写业务</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;
    @RequestMapping(&quot;&#x2F;hello&quot;)
    public String handle01()&#123;
        return &quot;Hello, Spring Boot 2!&quot;;
    &#125;
&#125;</code></pre>

<h4 id="运行-amp-测试"><a href="#运行-amp-测试" class="headerlink" title="运行&amp;测试"></a>运行&amp;测试</h4><ul>
<li>运行<code>MainApplication</code>类</li>
<li>浏览器输入<code>http://localhost:8888/hello</code>，将会输出<code>Hello, Spring Boot 2!</code>。</li>
</ul>
<h4 id="设置配置"><a href="#设置配置" class="headerlink" title="设置配置"></a>设置配置</h4><p>maven工程的resource文件夹中创建application.properties文件。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 设置端口号
server.port&#x3D;8888</code></pre>

<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server">更多配置信息</a></p>
<h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><p>在pom.xml添加</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;plugin&gt;
	&lt;&#x2F;plugins&gt;
&lt;&#x2F;build&gt;</code></pre>

<p>在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，</p>
<p>打包好的jar包被生成在helloworld工程项目的target文件夹内。</p>
<p>用cmd运行<code>java -jar boot-01-helloworld-1.0-SNAPSHOT.jar</code>，既可以运行helloworld工程项目。</p>
<p>将jar包直接在目标服务器执行即可。</p>
<h2 id="06、基础入门-SpringBoot-依赖管理特性"><a href="#06、基础入门-SpringBoot-依赖管理特性" class="headerlink" title="06、基础入门-SpringBoot-依赖管理特性"></a>06、基础入门-SpringBoot-依赖管理特性</h2><ul>
<li>父项目做依赖管理</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">依赖管理
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
	&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
&lt;&#x2F;parent&gt;

上面项目的父项目如下：
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;
	&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
&lt;&#x2F;parent&gt;

它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制</code></pre>

<ul>
<li>开发导入starter场景启动器<ol>
<li>见到很多 spring-boot-starter-* ： *就某种场景</li>
<li>只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">更多SpringBoot所有支持的场景</a></li>
<li>见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">所有场景启动器最底层的依赖
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;
	&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
	&lt;scope&gt;compile&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li><p>无需关注版本号，自动版本仲裁</p>
<ol>
<li>引入依赖默认都可以不写版本</li>
<li>引入非版本仲裁的jar，要写版本号。</li>
</ol>
</li>
<li><p>可以修改默认版本号</p>
<ol>
<li>查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</li>
<li>在当前项目里面重写配置，如下面的代码。</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;properties&gt;
	&lt;mysql.version&gt;5.1.43&lt;&#x2F;mysql.version&gt;
&lt;&#x2F;properties&gt;</code></pre>

<hr>
<p>IDEA快捷键：</p>
<ul>
<li><code> ctrl + shift + alt + U</code>：以图的方式显示项目中依赖之间的关系。</li>
<li><code>alt + ins</code>：相当于Eclipse的 Ctrl + N，创建新类，新包等。</li>
</ul>
<h2 id="07、基础入门-SpringBoot-自动配置特性"><a href="#07、基础入门-SpringBoot-自动配置特性" class="headerlink" title="07、基础入门-SpringBoot-自动配置特性"></a>07、基础入门-SpringBoot-自动配置特性</h2><ul>
<li>自动配好Tomcat<ul>
<li>引入Tomcat依赖。</li>
<li>配置Tomcat</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;
	&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
	&lt;scope&gt;compile&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li><p>自动配好SpringMVC</p>
<ul>
<li>引入SpringMVC全套组件</li>
<li>自动配好SpringMVC常用组件（功能）</li>
</ul>
</li>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
<ul>
<li>SpringBoot帮我们配置好了所有web开发的常见场景</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
    &#x2F;&#x2F;1、返回我们IOC容器
    ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);

    &#x2F;&#x2F;2、查看容器里面的组件
    String[] names &#x3D; run.getBeanDefinitionNames();
    for (String name : names) &#123;
        System.out.println(name);
    &#125;
&#125;</code></pre>

<ul>
<li>默认的包结构<ul>
<li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li>
<li>无需以前的包扫描配置</li>
<li>想要改变扫描路径<ul>
<li>@SpringBootApplication(scanBasePackages&#x3D;”com.lun”)</li>
<li>@ComponentScan 指定扫描路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication
等同于
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(&quot;com.lun&quot;)</code></pre>

<ul>
<li><p>各种配置拥有默认值</p>
<ul>
<li>默认配置最终都是映射到某个类上，如：<code>MultipartProperties</code></li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li><h2 id="按需加载所有自动配置项-非常多的starter-引入了哪些场景这个场景的自动配置才会开启-SpringBoot所有的自动配置功能都在-spring-boot-autoconfigure-包里面"><a href="#按需加载所有自动配置项-非常多的starter-引入了哪些场景这个场景的自动配置才会开启-SpringBoot所有的自动配置功能都在-spring-boot-autoconfigure-包里面" class="headerlink" title="按需加载所有自动配置项- 非常多的starter- 引入了哪些场景这个场景的自动配置才会开启- SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面"></a>按需加载所有自动配置项<br>- 非常多的starter<br>- 引入了哪些场景这个场景的自动配置才会开启<br>- SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</h2></li>
<li><p>……</p>
</li>
</ul>
<h2 id="08、底层注解-Configuration详解"><a href="#08、底层注解-Configuration详解" class="headerlink" title="08、底层注解-@Configuration详解"></a>08、底层注解-@Configuration详解</h2><ul>
<li>基本使用<ul>
<li>Full模式与Lite模式</li>
<li>示例</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的
 * 2、配置类本身也是组件
 * 3、proxyBeanMethods：代理bean的方法
 *      Full(proxyBeanMethods &#x3D; true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认）
 *      Lite(proxyBeanMethods &#x3D; false)（每个@Bean方法被调用多少次返回的组件都是新创建的）
 *&#x2F;
@Configuration(proxyBeanMethods &#x3D; false) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件
public class MyConfig &#123;

    &#x2F;**
     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象
     * @return
     *&#x2F;
    @Bean &#x2F;&#x2F;给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user01()&#123;
        User zhangsan &#x3D; new User(&quot;zhangsan&quot;, 18);
        &#x2F;&#x2F;user组件依赖了Pet组件
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    &#125;

    @Bean(&quot;tom&quot;)
    public Pet tomcatPet()&#123;
        return new Pet(&quot;tomcat&quot;);
    &#125;
&#125;</code></pre>


<p>@Configuration测试代码如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(&quot;com.atguigu.boot&quot;)
public class MainApplication &#123;

    public static void main(String[] args) &#123;
    &#x2F;&#x2F;1、返回我们IOC容器
        ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);

    &#x2F;&#x2F;2、查看容器里面的组件
        String[] names &#x3D; run.getBeanDefinitionNames();
        for (String name : names) &#123;
            System.out.println(name);
        &#125;

    &#x2F;&#x2F;3、从容器中获取组件
        Pet tom01 &#x3D; run.getBean(&quot;tom&quot;, Pet.class);
        Pet tom02 &#x3D; run.getBean(&quot;tom&quot;, Pet.class);
        System.out.println(&quot;组件：&quot;+(tom01 &#x3D;&#x3D; tom02));

    &#x2F;&#x2F;4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892
        MyConfig bean &#x3D; run.getBean(MyConfig.class);
        System.out.println(bean);

    &#x2F;&#x2F;如果@Configuration(proxyBeanMethods &#x3D; true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。
        &#x2F;&#x2F;保持组件单实例
        User user &#x3D; bean.user01();
        User user1 &#x3D; bean.user01();
        System.out.println(user &#x3D;&#x3D; user1);

        User user01 &#x3D; run.getBean(&quot;user01&quot;, User.class);
        Pet tom &#x3D; run.getBean(&quot;tom&quot;, Pet.class);

        System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() &#x3D;&#x3D; tom));
    &#125;
&#125;</code></pre>

<ul>
<li>最佳实战<ul>
<li>配置 类组件之间<strong>无依赖关系</strong>用Lite模式加速容器启动过程，减少判断</li>
<li>配置 类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件，用Full模式（默认）</li>
</ul>
</li>
</ul>
<blockquote>
<p>lite 英 [laɪt]   美 [laɪt]<br>adj. 低热量的，清淡的(light的一种拼写方法);类似…的劣质品</p>
</blockquote>
<hr>
<p>IDEA快捷键：</p>
<ul>
<li><code>Alt + Ins</code>:生成getter，setter、构造器等代码。</li>
<li><code>Ctrl + Alt + B</code>:查看类的具体实现代码。</li>
</ul>
<h2 id="09、底层注解-Import导入组件"><a href="#09、底层注解-Import导入组件" class="headerlink" title="09、底层注解-@Import导入组件"></a>09、底层注解-@Import导入组件</h2><p>@Bean、@Component、@Controller、@Service、@Repository，它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能。</p>
<p>@ComponentScan 在<a href="#">07、基础入门-SpringBoot-自动配置特性</a>有用例。</p>
<p>@Import({User.class, DBHelper.class})给容器中<strong>自动创建出这两个类型的组件</strong>、默认组件的名字就是全类名</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(&#123;User.class, DBHelper.class&#125;)
@Configuration(proxyBeanMethods &#x3D; false) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件
public class MyConfig &#123;
&#125;</code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;1、返回我们IOC容器
ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);

&#x2F;&#x2F;...

&#x2F;&#x2F;5、获取组件
String[] beanNamesForType &#x3D; run.getBeanNamesForType(User.class);

for (String s : beanNamesForType) &#123;
    System.out.println(s);
&#125;

DBHelper bean1 &#x3D; run.getBean(DBHelper.class);
System.out.println(bean1);</code></pre>

<h2 id="10、底层注解-Conditional条件装配"><a href="#10、底层注解-Conditional条件装配" class="headerlink" title="10、底层注解-@Conditional条件装配"></a>10、底层注解-@Conditional条件装配</h2><p><strong>条件装配：满足Conditional指定的条件，则进行组件注入</strong></p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005453173.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>用@ConditionalOnMissingBean举例说明</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnMissingBean(name &#x3D; &quot;tom&quot;)&#x2F;&#x2F;没有tom名字的Bean时，MyConfig类的Bean才能生效。
public class MyConfig &#123;

    @Bean
    public User user01()&#123;
        User zhangsan &#x3D; new User(&quot;zhangsan&quot;, 18);
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    &#125;

    @Bean(&quot;tom22&quot;)
    public Pet tomcatPet()&#123;
        return new Pet(&quot;tomcat&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    &#x2F;&#x2F;1、返回我们IOC容器
    ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);

    &#x2F;&#x2F;2、查看容器里面的组件
    String[] names &#x3D; run.getBeanDefinitionNames();
    for (String name : names) &#123;
        System.out.println(name);
    &#125;

    boolean tom &#x3D; run.containsBean(&quot;tom&quot;);
    System.out.println(&quot;容器中Tom组件：&quot;+tom);&#x2F;&#x2F;false

    boolean user01 &#x3D; run.containsBean(&quot;user01&quot;);
    System.out.println(&quot;容器中user01组件：&quot;+user01);&#x2F;&#x2F;true

    boolean tom22 &#x3D; run.containsBean(&quot;tom22&quot;);
    System.out.println(&quot;容器中tom22组件：&quot;+tom22);&#x2F;&#x2F;true

&#125;</code></pre>

<h2 id="11、底层注解-ImportResource导入Spring配置文件"><a href="#11、底层注解-ImportResource导入Spring配置文件" class="headerlink" title="11、底层注解-@ImportResource导入Spring配置文件"></a>11、底层注解-@ImportResource导入Spring配置文件</h2><p>比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。</p>
<p>bean.xml：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans ...&quot;&gt;

    &lt;bean id&#x3D;&quot;haha&quot; class&#x3D;&quot;com.lun.boot.bean.User&quot;&gt;
        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;
    &lt;&#x2F;bean&gt;

    &lt;bean id&#x3D;&quot;hehe&quot; class&#x3D;&quot;com.lun.boot.bean.Pet&quot;&gt;
        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;tomcat&quot;&gt;&lt;&#x2F;property&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>

<p>使用方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ImportResource(&quot;classpath:beans.xml&quot;)
public class MyConfig &#123;
...
&#125;</code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
    &#x2F;&#x2F;1、返回我们IOC容器
    ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);

	boolean haha &#x3D; run.containsBean(&quot;haha&quot;);
	boolean hehe &#x3D; run.containsBean(&quot;hehe&quot;);
	System.out.println(&quot;haha：&quot;+haha);&#x2F;&#x2F;true
	System.out.println(&quot;hehe：&quot;+hehe);&#x2F;&#x2F;true
&#125;</code></pre>

<h2 id="12、底层注解-ConfigurationProperties配置绑定"><a href="#12、底层注解-ConfigurationProperties配置绑定" class="headerlink" title="12、底层注解-@ConfigurationProperties配置绑定"></a>12、底层注解-@ConfigurationProperties配置绑定</h2><p>如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用</p>
<p>传统方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class getProperties &#123;
     public static void main(String[] args) throws FileNotFoundException, IOException &#123;
         Properties pps &#x3D; new Properties();
         pps.load(new FileInputStream(&quot;a.properties&quot;));
         Enumeration enum1 &#x3D; pps.propertyNames();&#x2F;&#x2F;得到配置文件的名字
         while(enum1.hasMoreElements()) &#123;
             String strKey &#x3D; (String) enum1.nextElement();
             String strValue &#x3D; pps.getProperty(strKey);
             System.out.println(strKey + &quot;&#x3D;&quot; + strValue);
             &#x2F;&#x2F;封装到JavaBean。
         &#125;
     &#125;
 &#125;</code></pre>

<hr>
<p>Spring Boot一种配置配置绑定：</p>
<p>@ConfigurationProperties + @Component</p>
<p>假设有配置文件application.properties</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">mycar.brand&#x3D;BYD
mycar.price&#x3D;100000</code></pre>

<p>只有在容器中的组件，才会拥有SpringBoot提供的强大功能</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)
public class Car &#123;
...
&#125;</code></pre>

<hr>
<p>Spring Boot另一种配置配置绑定：</p>
<p>@EnableConfigurationProperties + @ConfigurationProperties</p>
<ol>
<li>开启Car配置绑定功能</li>
<li>把这个Car这个组件自动注册到容器中</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableConfigurationProperties(Car.class)
public class MyConfig &#123;
...
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)
public class Car &#123;
...
&#125;</code></pre>

<h2 id="13、自动配置【源码分析】-自动包规则原理"><a href="#13、自动配置【源码分析】-自动包规则原理" class="headerlink" title="13、自动配置【源码分析】-自动包规则原理"></a>13、自动配置【源码分析】-自动包规则原理</h2><p>Spring Boot应用的启动类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class, args);
    &#125;

&#125;</code></pre>

<p>分析下<code>@SpringBootApplication</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters &#x3D; &#123;@Filter(
    type &#x3D; FilterType.CUSTOM,
    classes &#x3D; &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type &#x3D; FilterType.CUSTOM,
    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
public @interface SpringBootApplication &#123;
    ...
&#125;</code></pre>

<p>重点分析<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration &#123;
    @AliasFor(
        annotation &#x3D; Configuration.class
    )
    boolean proxyBeanMethods() default true;
&#125;</code></pre>

<p><code>@Configuration</code>代表当前是一个配置类。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>指定扫描哪些Spring注解。</p>
<p>@ComponentScan 在<a href="#">07、基础入门-SpringBoot-自动配置特性</a>有用例。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;</code></pre>

<p>重点分析<code>@AutoConfigurationPackage</code>，<code>@Import(AutoConfigurationImportSelector.class)</code>。</p>
<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>标签名直译为：自动配置包，指定了默认的包规则。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)&#x2F;&#x2F;给容器中导入一个组件
public @interface AutoConfigurationPackage &#123;
    String[] basePackages() default &#123;&#125;;

    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;
&#125;</code></pre>

<ol>
<li>利用Registrar给容器中导入一系列组件</li>
<li>将指定的一个包下的所有组件导入进MainApplication所在包下。</li>
</ol>
<h2 id="14、自动配置【源码分析】-初始加载自动配置类"><a href="#14、自动配置【源码分析】-初始加载自动配置类" class="headerlink" title="14、自动配置【源码分析】-初始加载自动配置类"></a>14、自动配置【源码分析】-初始加载自动配置类</h2><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h4><ol>
<li>利用<code>getAutoConfigurationEntry(annotationMetadata);</code>给容器中批量导入一些组件</li>
<li>调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>获取到所有需要导入到容器中的配置类</li>
<li>利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader);</code>得到所有的组件</li>
<li>从<code>META-INF/spring.factories</code>位置来加载一个文件。<ul>
<li>默认扫描我们当前系统里面所有<code>META-INF/spring.factories</code>位置的文件</li>
<li><code>spring-boot-autoconfigure-2.3.4.RELEASE.jar</code>包里面也有<code>META-INF/spring.factories</code></li>
</ul>
</li>
</ol>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005536620.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类
# spring-boot-autoconfigure-2.3.4.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
...</code></pre>

<p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p>
<p>如<code>AopAutoConfiguration</code>类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(
    proxyBeanMethods &#x3D; false
)
@ConditionalOnProperty(
    prefix &#x3D; &quot;spring.aop&quot;,
    name &#x3D; &quot;auto&quot;,
    havingValue &#x3D; &quot;true&quot;,
    matchIfMissing &#x3D; true
)
public class AopAutoConfiguration &#123;
    public AopAutoConfiguration() &#123;
    &#125;
	...
&#125;</code></pre>

<h2 id="15、自动配置【源码分析】-自动配置流程"><a href="#15、自动配置【源码分析】-自动配置流程" class="headerlink" title="15、自动配置【源码分析】-自动配置流程"></a>15、自动配置【源码分析】-自动配置流程</h2><p>以<code>DispatcherServletAutoConfiguration</code>的内部类<code>DispatcherServletConfiguration</code>为例子:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean
@ConditionalOnBean(MultipartResolver.class)  &#x2F;&#x2F;容器中有这个类型组件
@ConditionalOnMissingBean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) &#x2F;&#x2F;容器中没有这个名字 multipartResolver 的组件
public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;
	&#x2F;&#x2F;给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。
	&#x2F;&#x2F;SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范
	&#x2F;&#x2F; Detect if the user has created a MultipartResolver but named it incorrectly
	return resolver;&#x2F;&#x2F;给容器中加入了文件上传解析器；
&#125;</code></pre>

<p>SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了以用户的优先</strong>。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</li>
<li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）</li>
<li>生效的配置类就会给容器中装配很多组件</li>
<li>只要容器中有这些组件，相当于这些功能就有了</li>
<li>定制化配置<ul>
<li>用户直接自己@Bean替换底层的组件</li>
<li>用户去看这个组件是获取的配置文件什么值就去修改。</li>
</ul>
</li>
</ul>
<p><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值  —-&gt; application.properties</strong></p>
<h2 id="16、最佳实践-SpringBoot应用如何编写"><a href="#16、最佳实践-SpringBoot应用如何编写" class="headerlink" title="16、最佳实践-SpringBoot应用如何编写"></a>16、最佳实践-SpringBoot应用如何编写</h2><ul>
<li>引入场景依赖<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">官方文档</a></li>
</ul>
</li>
<li>查看自动配置了哪些（选做）<ul>
<li>自己分析，引入场景对应的自动配置一般都生效了</li>
<li>配置文件中debug&#x3D;true开启自动配置报告。<ul>
<li>Negative（不生效）</li>
<li>Positive（生效）</li>
</ul>
</li>
</ul>
</li>
<li>是否需要修改<ul>
<li>参照文档修改配置项<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">官方文档</a></li>
<li>自己分析。xxxxProperties绑定了配置文件的哪些。</li>
</ul>
</li>
<li>自定义加入或者替换组件<ul>
<li>@Bean、@Component…</li>
</ul>
</li>
<li>自定义器  XXXXXCustomizer；</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="17、最佳实践-Lombok简化开发"><a href="#17、最佳实践-Lombok简化开发" class="headerlink" title="17、最佳实践-Lombok简化开发"></a>17、最佳实践-Lombok简化开发</h2><p>Lombok用标签方式代替构造器、getter&#x2F;setter、toString()等鸡肋代码。</p>
<p>spring boot已经管理Lombok。引入依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> &lt;dependency&gt;
     &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;
     &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>IDEA中File-&gt;Settings-&gt;Plugins，搜索安装Lombok插件。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@NoArgsConstructor
&#x2F;&#x2F;@AllArgsConstructor
@Data
@ToString
@EqualsAndHashCode
public class User &#123;

    private String name;
    private Integer age;

    private Pet pet;

    public User(String name,Integer age)&#123;
        this.name &#x3D; name;
        this.age &#x3D; age;
    &#125;
&#125;</code></pre>

<hr>
<p>简化日志开发</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@RestController
public class HelloController &#123;
    @RequestMapping(&quot;&#x2F;hello&quot;)
    public String handle01(@RequestParam(&quot;name&quot;) String name)&#123;
        log.info(&quot;请求进来了....&quot;);
        return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name;
    &#125;
&#125;</code></pre>

<h2 id="18、最佳实践-dev-tools"><a href="#18、最佳实践-dev-tools" class="headerlink" title="18、最佳实践-dev-tools"></a>18、最佳实践-dev-tools</h2><blockquote>
<p>Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The <code>spring-boot-devtools</code> module can be included in any project to provide additional development-time features.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools">link</a></p>
<p>Applications that use <code>spring-boot-devtools</code> automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart-exclude">do not need to restart the application</a>.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart">link</a></p>
<p>Triggering a restart</p>
<p>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using:</p>
<ul>
<li>In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.</li>
<li>In IntelliJ IDEA, building the project (<code>Build -&gt; Build Project</code>)(shortcut: Ctrl+F9) has the same effect.</li>
</ul>
</blockquote>
<p>添加依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;
        &lt;optional&gt;true&lt;&#x2F;optional&gt;
    &lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;</code></pre>

<p>在IDEA中，项目或者页面修改以后：Ctrl+F9。</p>
<h2 id="19、最佳实践-Spring-Initailizr"><a href="#19、最佳实践-Spring-Initailizr" class="headerlink" title="19、最佳实践-Spring Initailizr"></a>19、最佳实践-Spring Initailizr</h2><p><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initailizr</a>是创建Spring Boot工程向导。</p>
<p>在IDEA中，菜单栏New -&gt; Project -&gt; Spring Initailizr。</p>
<h1 id="SpringBoot2核心技术-核心功能"><a href="#SpringBoot2核心技术-核心功能" class="headerlink" title="SpringBoot2核心技术-核心功能"></a><strong>SpringBoot2核心技术-核心功能</strong></h1><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211458073.jpg" srcset="/img/loading.gif" lazyload alt="yuque_diagram"></p>
<p><strong>SpringBoot2核心技术-核心功能</strong></p>
<h2 id="20、配置文件-yaml的用法"><a href="#20、配置文件-yaml的用法" class="headerlink" title="20、配置文件-yaml的用法"></a>20、配置文件-yaml的用法</h2><p>同以前的properties用法</p>
<p>YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 </p>
<p><strong>非常适合用来做以数据为中心的配置文件</strong>。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>key: value；kv之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
<li>字符串无需加引号，如果要加，单引号’’、双引号””表示字符串内容会被 转义、不转义</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">k: v</code></pre>

<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#行内写法：  

k: &#123;k1:v1,k2:v2,k3:v3&#125;

#或

k: 
  k1: v1
  k2: v2
  k3: v3</code></pre>

<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#行内写法：  

k: [v1,v2,v3]

#或者

k:
 - v1
 - v2
 - v3</code></pre>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data
public class Person &#123;
    private String userName;
    private Boolean boss;
    private Date birth;
    private Integer age;
    private Pet pet;
    private String[] interests;
    private List&lt;String&gt; animal;
    private Map&lt;String, Object&gt; score;
    private Set&lt;Double&gt; salarys;
    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;
&#125;

@Data
public class Pet &#123;
    private String name;
    private Double weight;
&#125;</code></pre>

<p>用yaml表示以上对象</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">person:
  userName: zhangsan
  boss: false
  birth: 2019&#x2F;12&#x2F;12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: &#123;first: 128,second: 136&#125;
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - &#123;name: tom&#125;
      - &#123;name: jerry,weight: 47&#125;
    health: [&#123;name: mario,weight: 47&#125;]</code></pre>

<h2 id="21、配置文件-自定义类绑定的配置提示"><a href="#21、配置文件-自定义类绑定的配置提示" class="headerlink" title="21、配置文件-自定义类绑定的配置提示"></a>21、配置文件-自定义类绑定的配置提示</h2><blockquote>
<p>You can easily generate your own configuration metadata file from items annotated with <code>@ConfigurationProperties</code> by using the <code>spring-boot-configuration-processor</code> jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor">link</a></p>
</blockquote>
<p>自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;
    &lt;optional&gt;true&lt;&#x2F;optional&gt;
&lt;&#x2F;dependency&gt;

&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;
            &lt;configuration&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
                        &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;
                    &lt;&#x2F;exclude&gt;
                &lt;&#x2F;excludes&gt;
            &lt;&#x2F;configuration&gt;
        &lt;&#x2F;plugin&gt;
    &lt;&#x2F;plugins&gt;
&lt;&#x2F;build&gt;</code></pre>

<h2 id="22、web场景-web开发简介"><a href="#22、web场景-web开发简介" class="headerlink" title="22、web场景-web开发简介"></a>22、web场景-web开发简介</h2><p>Spring Boot provides auto-configuration for Spring MVC that <strong>works well with most applications.(大多场景我们都无需自定义配置)</strong></p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>内容协商视图解析器和BeanName视图解析器</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">later in this document</a>)).</p>
<ul>
<li>静态资源（包括webjars）</li>
</ul>
</li>
<li><p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</p>
<ul>
<li>自动注册 <code>Converter，GenericConverter，Formatter </code></li>
</ul>
</li>
<li><p>Support for <code>HttpMessageConverters</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">later in this document</a>).</p>
<ul>
<li>支持 <code>HttpMessageConverters</code> （后来我们配合内容协商理解原理）</li>
</ul>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes">later in this document</a>).</p>
<ul>
<li>自动注册 <code>MessageCodesResolver</code> （国际化用）</li>
</ul>
</li>
<li><p>Static <code>index.html</code> support.</p>
<ul>
<li>静态index.html 页支持</li>
</ul>
</li>
<li><p>Custom <code>Favicon</code> support (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">later in this document</a>).</p>
<ul>
<li>自定义 <code>Favicon</code></li>
</ul>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</p>
<ul>
<li>自动使用 <code>ConfigurableWebBindingInitializer</code> ，（DataBinder负责将请求数据绑定到JavaBean上）</li>
</ul>
</li>
</ul>
<blockquote>
<p>If you want to keep those Spring Boot MVC customizations and make more <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<p><strong>不用@EnableWebMvc注解。使用</strong> <strong><code>@Configuration</code></strong> <strong>+</strong> <strong><code>WebMvcConfigurer</code></strong> <strong>自定义规则</strong></p>
</blockquote>
<blockquote>
<p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p>
<p><strong>声明</strong> <strong><code>WebMvcRegistrations</code></strong> <strong>改变默认底层组件</strong></p>
</blockquote>
<blockquote>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p><strong>使用</strong> <strong><code>@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC</code></strong></p>
</blockquote>
<h2 id="23、web场景-静态资源规则与定制化"><a href="#23、web场景-静态资源规则与定制化" class="headerlink" title="23、web场景-静态资源规则与定制化"></a>23、web场景-静态资源规则与定制化</h2><h3 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h3><p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问 ： 当前项目根路径&#x2F; + 静态资源名 </p>
<p>原理： 静态映射&#x2F;**。</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。</p>
<p>也可以改变默认的静态资源路径，<code>/static</code>，<code>/public</code>,<code>/resources</code>, <code>/META-INF/resources</code>失效</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">resources:
  static-locations: [classpath:&#x2F;haha&#x2F;]</code></pre>

<h3 id="静态资源访问前缀"><a href="#静态资源访问前缀" class="headerlink" title="静态资源访问前缀"></a>静态资源访问前缀</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  mvc:
    static-path-pattern: &#x2F;res&#x2F;**</code></pre>

<p>当前项目 + static-path-pattern + 静态资源名 &#x3D; 静态资源文件夹下找</p>
<h3 id="webjar"><a href="#webjar" class="headerlink" title="webjar"></a>webjar</h3><p>可用jar方式添加css，js等资源文件，</p>
<p><a target="_blank" rel="noopener" href="https://www.webjars.org/">https://www.webjars.org/</a></p>
<p>例如，添加jquery</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.5.1&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">http://localhost:8080/webjars/<strong>jquery&#x2F;3.5.1&#x2F;jquery.js</strong></a>  后面地址要按照依赖里面的包路径。</p>
<h2 id="24、web场景-welcome与favicon功能"><a href="#24、web场景-welcome与favicon功能" class="headerlink" title="24、web场景-welcome与favicon功能"></a>24、web场景-welcome与favicon功能</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-welcome-page">官方文档</a></p>
<h3 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h3><ul>
<li><p>静态资源路径下  index.html。</p>
<ul>
<li>可以配置静态资源路径</li>
<li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
#  mvc:
#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致welcome page功能失效
  resources:
    static-locations: [classpath:&#x2F;haha&#x2F;]</code></pre>

<ul>
<li>controller能处理&#x2F;index。</li>
</ul>
<h3 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h3><p>指网页标签上的小图标。</p>
<p>favicon.ico 放在静态资源目录下即可。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
#  mvc:
#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致 Favicon 功能失效</code></pre>

<h2 id="25、web场景-【源码分析】-静态资源原理"><a href="#25、web场景-【源码分析】-静态资源原理" class="headerlink" title="25、web场景-【源码分析】-静态资源原理"></a>25、web场景-【源码分析】-静态资源原理</h2><ul>
<li>SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</li>
<li>SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code>，生效</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;
    ...
&#125;</code></pre>

<ul>
<li>给容器中配置的内容：<ul>
<li>配置文件的相关属性的绑定：WebMvcProperties&#x3D;&#x3D;<strong>spring.mvc</strong>、ResourceProperties&#x3D;&#x3D;<strong>spring.resources</strong></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@Import(EnableWebMvcConfiguration.class)
@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)
@Order(0)
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;
    ...
&#125;</code></pre>

<h3 id="配置类只有一个有参构造器"><a href="#配置类只有一个有参构造器" class="headerlink" title="配置类只有一个有参构造器"></a>配置类只有一个有参构造器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;&#x2F;&#x2F;有参构造器所有参数的值都会从容器中确定
public WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties,
		ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,
		ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,
		ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,
		ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;
	this.mvcProperties &#x3D; mvcProperties;
	this.beanFactory &#x3D; beanFactory;
	this.messageConvertersProvider &#x3D; messageConvertersProvider;
	this.resourceHandlerRegistrationCustomizer &#x3D; resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
	this.dispatcherServletPath &#x3D; dispatcherServletPath;
	this.servletRegistrations &#x3D; servletRegistrations;
	this.mvcProperties.checkConfiguration();
&#125;</code></pre>

<ul>
<li>ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</li>
<li>WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</li>
<li>ListableBeanFactory beanFactory Spring的beanFactory</li>
<li>HttpMessageConverters 找到所有的HttpMessageConverters</li>
<li>ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。</li>
<li>DispatcherServletPath</li>
<li>ServletRegistrationBean   给应用注册Servlet、Filter….</li>
</ul>
<h3 id="资源处理的默认规则"><a href="#资源处理的默认规则" class="headerlink" title="资源处理的默认规则"></a>资源处理的默认规则</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">...
public class WebMvcAutoConfiguration &#123;
    ...
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;
        ...
		@Override
		protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
			super.addResourceHandlers(registry);
			if (!this.resourceProperties.isAddMappings()) &#123;
				logger.debug(&quot;Default resource handling disabled&quot;);
				return;
			&#125;
			ServletContext servletContext &#x3D; getServletContext();
			addResourceHandler(registry, &quot;&#x2F;webjars&#x2F;**&quot;, &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;);
			addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;
				registration.addResourceLocations(this.resourceProperties.getStaticLocations());
				if (servletContext !&#x3D; null) &#123;
					registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));
				&#125;
			&#125;);
		&#125;
        ...
        
    &#125;
    ...
&#125;</code></pre>

<p>根据上述代码，我们可以同过配置禁止所有静态资源规则。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  resources:
    add-mappings: false   #禁用所有静态资源规则</code></pre>

<p>静态资源规则：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ConfigurationProperties(prefix &#x3D; &quot;spring.resources&quot;, ignoreUnknownFields &#x3D; false)
public class ResourceProperties &#123;

    private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,
            &quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;

    &#x2F;**
     * Locations of static resources. Defaults to classpath:[&#x2F;META-INF&#x2F;resources&#x2F;,
     * &#x2F;resources&#x2F;, &#x2F;static&#x2F;, &#x2F;public&#x2F;].
     *&#x2F;
    private String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;
    ...
&#125;
</code></pre>

<h3 id="欢迎页的处理规则"><a href="#欢迎页的处理规则" class="headerlink" title="欢迎页的处理规则"></a>欢迎页的处理规则</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">...
public class WebMvcAutoConfiguration &#123;
    ...
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;
        ...
		@Bean
		public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
				FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;
			WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(
					new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
					this.mvcProperties.getStaticPathPattern());
			welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
			welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());
			return welcomePageHandlerMapping;
		&#125;
    </code></pre>

<p><code>WelcomePageHandlerMapping</code>的构造方法如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
                          ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123;
    if (welcomePage !&#x3D; null &amp;&amp; &quot;&#x2F;**&quot;.equals(staticPathPattern)) &#123;
        &#x2F;&#x2F;要用欢迎页功能，必须是&#x2F;**
        logger.info(&quot;Adding welcome page: &quot; + welcomePage);
        setRootViewName(&quot;forward:index.html&quot;);
    &#125;
    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;
        &#x2F;&#x2F;调用Controller &#x2F;index
        logger.info(&quot;Adding welcome page template: index&quot;);
        setRootViewName(&quot;index&quot;);
    &#125;
&#125;</code></pre>

<p>这构造方法内的代码也解释了<a href="#">web场景-welcome与favicon功能</a>中配置<code>static-path-pattern</code>了，welcome页面和小图标失效的问题。</p>
<h2 id="26、请求处理-【源码分析】-Rest映射及源码解析"><a href="#26、请求处理-【源码分析】-Rest映射及源码解析" class="headerlink" title="26、请求处理-【源码分析】-Rest映射及源码解析"></a>26、请求处理-【源码分析】-Rest映射及源码解析</h2><h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><ul>
<li><p>@xxxMapping;</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
</ul>
</li>
<li><p>Rest风格支持（使用<strong>HTTP</strong>请求方式动词来表示对资源的操作）</p>
<ul>
<li>以前：<ul>
<li>&#x2F;getUser 获取用户</li>
<li>&#x2F;deleteUser 删除用户</li>
<li>&#x2F;editUser 修改用户</li>
<li>&#x2F;saveUser保存用户</li>
</ul>
</li>
<li>现在： &#x2F;user <ul>
<li>GET-获取用户</li>
<li>DELETE-删除用户</li>
<li>PUT-修改用户</li>
<li>POST-保存用户</li>
</ul>
</li>
<li>核心Filter；HiddenHttpMethodFilter</li>
</ul>
</li>
<li><p><strong>用法</strong></p>
<ul>
<li>开启页面表单的Rest功能</li>
<li>页面 form的属性method&#x3D;post，隐藏域 _method&#x3D;put、delete等（如果直接get或post，无需隐藏域）</li>
<li>编写请求映射</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能</code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;get&quot;&gt;
    &lt;input value&#x3D;&quot;REST-GET提交&quot; type&#x3D;&quot;submit&quot; &#x2F;&gt;
&lt;&#x2F;form&gt;

&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;
    &lt;input value&#x3D;&quot;REST-POST提交&quot; type&#x3D;&quot;submit&quot; &#x2F;&gt;
&lt;&#x2F;form&gt;

&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;
    &lt;input name&#x3D;&quot;_method&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;DELETE&quot;&#x2F;&gt;
    &lt;input value&#x3D;&quot;REST-DELETE 提交&quot; type&#x3D;&quot;submit&quot;&#x2F;&gt;
&lt;&#x2F;form&gt;

&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;
    &lt;input name&#x3D;&quot;_method&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;PUT&quot; &#x2F;&gt;
    &lt;input value&#x3D;&quot;REST-PUT提交&quot;type&#x3D;&quot;submit&quot; &#x2F;&gt;
&lt;form&gt;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;user&quot;)
&#x2F;&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.GET)
public String getUser()&#123;
    return &quot;GET-张三&quot;;
&#125;

@PostMapping(&quot;&#x2F;user&quot;)
&#x2F;&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.POST)
public String saveUser()&#123;
    return &quot;POST-张三&quot;;
&#125;

@PutMapping(&quot;&#x2F;user&quot;)
&#x2F;&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.PUT)
public String putUser()&#123;
    return &quot;PUT-张三&quot;;
&#125;

@DeleteMapping(&quot;&#x2F;user&quot;)
&#x2F;&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.DELETE)
public String deleteUser()&#123;
    return &quot;DELETE-张三&quot;;
&#125;</code></pre>

<ul>
<li>Rest原理（表单提交要使用REST的时候）<ul>
<li>表单提交会带上<code>\_method=PUT</code></li>
<li><strong>请求过来被</strong><code>HiddenHttpMethodFilter</code>拦截<ul>
<li>请求是否正常，并且是POST<ul>
<li>获取到<code>\_method</code>的值。</li>
<li>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></li>
<li><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></li>
<li><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HiddenHttpMethodFilter extends OncePerRequestFilter &#123;

	private static final List&lt;String&gt; ALLOWED_METHODS &#x3D;
			Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),
					HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));

	&#x2F;** Default method parameter: &#123;@code _method&#125;. *&#x2F;
	public static final String DEFAULT_METHOD_PARAM &#x3D; &quot;_method&quot;;

	private String methodParam &#x3D; DEFAULT_METHOD_PARAM;


	&#x2F;**
	 * Set the parameter name to look for HTTP methods.
	 * @see #DEFAULT_METHOD_PARAM
	 *&#x2F;
	public void setMethodParam(String methodParam) &#123;
		Assert.hasText(methodParam, &quot;&#39;methodParam&#39; must not be empty&quot;);
		this.methodParam &#x3D; methodParam;
	&#125;

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException &#123;

		HttpServletRequest requestToUse &#x3D; request;

		if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) &#x3D;&#x3D; null) &#123;
			String paramValue &#x3D; request.getParameter(this.methodParam);
			if (StringUtils.hasLength(paramValue)) &#123;
				String method &#x3D; paramValue.toUpperCase(Locale.ENGLISH);
				if (ALLOWED_METHODS.contains(method)) &#123;
					requestToUse &#x3D; new HttpMethodRequestWrapper(request, method);
				&#125;
			&#125;
		&#125;

		filterChain.doFilter(requestToUse, response);
	&#125;


	&#x2F;**
	 * Simple &#123;@link HttpServletRequest&#125; wrapper that returns the supplied method for
	 * &#123;@link HttpServletRequest#getMethod()&#125;.
	 *&#x2F;
	private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123;

		private final String method;

		public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123;
			super(request);
			this.method &#x3D; method;
		&#125;

		@Override
		public String getMethod() &#123;
			return this.method;
		&#125;
	&#125;

&#125;</code></pre>

<ul>
<li>Rest使用客户端工具。<ul>
<li>如PostMan可直接发送put、delete等方式请求。</li>
</ul>
</li>
</ul>
<h2 id="27、请求处理-【源码分析】-怎么改变默认的-method"><a href="#27、请求处理-【源码分析】-怎么改变默认的-method" class="headerlink" title="27、请求处理-【源码分析】-怎么改变默认的_method"></a>27、请求处理-【源码分析】-怎么改变默认的_method</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;

    ...
    
    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    @ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc.hiddenmethod.filter&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; false)
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;
        return new OrderedHiddenHttpMethodFilter();
    &#125;
    
    ...
&#125;
    </code></pre>

<p><code>@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</code>意味着在没有<code>HiddenHttpMethodFilter</code>时，才执行<code>hiddenHttpMethodFilter()</code>。因此，我们可以自定义filter，改变默认的<code>\_method</code>。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
public class WebConfig&#123;
    &#x2F;&#x2F;自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;
        HiddenHttpMethodFilter methodFilter &#x3D; new HiddenHttpMethodFilter();
        methodFilter.setMethodParam(&quot;_m&quot;);
        return methodFilter;
    &#125;    
&#125;</code></pre>

<p>将<code>\_method</code>改成<code>_m</code>。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;
    &lt;input name&#x3D;&quot;_m&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;DELETE&quot;&#x2F;&gt;
    &lt;input value&#x3D;&quot;REST-DELETE 提交&quot; type&#x3D;&quot;submit&quot;&#x2F;&gt;
&lt;&#x2F;form&gt;</code></pre>

<h2 id="28、请求处理-【源码分析】-请求映射原理"><a href="#28、请求处理-【源码分析】-请求映射原理" class="headerlink" title="28、请求处理-【源码分析】-请求映射原理"></a>28、请求处理-【源码分析】-请求映射原理</h2><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005703527.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>SpringMVC功能分析都从 <code>org.springframework.web.servlet.DispatcherServlet</code> -&gt; <code>doDispatch()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    HttpServletRequest processedRequest &#x3D; request;
    HandlerExecutionChain mappedHandler &#x3D; null;
    boolean multipartRequestParsed &#x3D; false;

    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);

    try &#123;
        ModelAndView mv &#x3D; null;
        Exception dispatchException &#x3D; null;

        try &#123;
            processedRequest &#x3D; checkMultipart(request);
            multipartRequestParsed &#x3D; (processedRequest !&#x3D; request);

            &#x2F;&#x2F; 找到当前请求使用哪个Handler（Controller的方法）处理
            mappedHandler &#x3D; getHandler(processedRequest);

            &#x2F;&#x2F;HandlerMapping：处理器映射。&#x2F;xxx-&gt;&gt;xxxx
    ...
&#125;</code></pre>

<p><code>getHandler()</code>方法如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Nullable
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
    if (this.handlerMappings !&#x3D; null) &#123;
        for (HandlerMapping mapping : this.handlerMappings) &#123;
            HandlerExecutionChain handler &#x3D; mapping.getHandler(request);
            if (handler !&#x3D; null) &#123;
                return handler;
            &#125;
        &#125;
    &#125;
    return null;
&#125;</code></pre>

<p><code>this.handlerMappings</code>在Debug模式下展现的内容：</p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005802305.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>其中，保存了所有<code>@RequestMapping</code> 和<code>handler</code>的映射规则。</p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205005926474.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>所有的请求映射都在HandlerMapping中：</p>
<ul>
<li><p>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 &#x2F;能访问到index.html；</p>
</li>
<li><p>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</p>
</li>
<li><p>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。</p>
<ul>
<li>如果有就找到这个请求对应的handler</li>
<li>如果没有就是下一个 HandlerMapping</li>
</ul>
</li>
<li><p>我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></p>
</li>
</ul>
<hr>
<p>IDEA快捷键：</p>
<ul>
<li>Ctrl + Alt + U : 以UML的类图展现类有哪些继承类，派生类以及实现哪些接口。</li>
<li>Crtl + Alt + Shift + U : 同上，区别在于上条快捷键结果在新页展现，而本条快捷键结果在弹窗展现。</li>
<li>Ctrl + H : 以树形方式展现类层次结构图。</li>
</ul>
<h2 id="29、请求处理-常用参数注解使用"><a href="#29、请求处理-常用参数注解使用" class="headerlink" title="29、请求处理-常用参数注解使用"></a>29、请求处理-常用参数注解使用</h2><p>注解：</p>
<ul>
<li><code>@PathVariable</code> 路径变量</li>
<li><code>@RequestHeader</code> 获取请求头</li>
<li><code>@RequestParam</code> 获取请求参数（指问号后的参数，url?a&#x3D;1&amp;b&#x3D;2）</li>
<li><code>@CookieValue</code> 获取Cookie值</li>
<li><code>@RequestAttribute</code> 获取request域属性</li>
<li><code>@RequestBody</code> 获取请求体[POST]</li>
<li><code>@MatrixVariable</code> 矩阵变量</li>
<li><code>@ModelAttribute</code></li>
</ul>
<p>使用用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
public class ParameterTestController &#123;


    &#x2F;&#x2F;  car&#x2F;2&#x2F;owner&#x2F;zhangsan
    @GetMapping(&quot;&#x2F;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)
    public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id,
                                     @PathVariable(&quot;username&quot;) String name,
                                     @PathVariable Map&lt;String,String&gt; pv,
                                     @RequestHeader(&quot;User-Agent&quot;) String userAgent,
                                     @RequestHeader Map&lt;String,String&gt; header,
                                     @RequestParam(&quot;age&quot;) Integer age,
                                     @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,
                                     @RequestParam Map&lt;String,String&gt; params,
                                     @CookieValue(&quot;_ga&quot;) String _ga,
                                     @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123;

        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();

&#x2F;&#x2F;        map.put(&quot;id&quot;,id);
&#x2F;&#x2F;        map.put(&quot;name&quot;,name);
&#x2F;&#x2F;        map.put(&quot;pv&quot;,pv);
&#x2F;&#x2F;        map.put(&quot;userAgent&quot;,userAgent);
&#x2F;&#x2F;        map.put(&quot;headers&quot;,header);
        map.put(&quot;age&quot;,age);
        map.put(&quot;inters&quot;,inters);
        map.put(&quot;params&quot;,params);
        map.put(&quot;_ga&quot;,_ga);
        System.out.println(cookie.getName()+&quot;&#x3D;&#x3D;&#x3D;&gt;&quot;+cookie.getValue());
        return map;
    &#125;


    @PostMapping(&quot;&#x2F;save&quot;)
    public Map postMethod(@RequestBody String content)&#123;
        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();
        map.put(&quot;content&quot;,content);
        return map;
    &#125;
&#125;</code></pre>

<h2 id="30、请求处理-RequestAttribute"><a href="#30、请求处理-RequestAttribute" class="headerlink" title="30、请求处理-@RequestAttribute"></a>30、请求处理-@RequestAttribute</h2><p>用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class RequestController &#123;

    @GetMapping(&quot;&#x2F;goto&quot;)
    public String goToPage(HttpServletRequest request)&#123;

        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);
        request.setAttribute(&quot;code&quot;,200);
        return &quot;forward:&#x2F;success&quot;;  &#x2F;&#x2F;转发到  &#x2F;success请求
    &#125;

    @GetMapping(&quot;&#x2F;params&quot;)
    public String testParam(Map&lt;String,Object&gt; map,
                            Model model,
                            HttpServletRequest request,
                            HttpServletResponse response)&#123;
        map.put(&quot;hello&quot;,&quot;world666&quot;);
        model.addAttribute(&quot;world&quot;,&quot;hello666&quot;);
        request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;);

        Cookie cookie &#x3D; new Cookie(&quot;c1&quot;,&quot;v1&quot;);
        response.addCookie(cookie);
        return &quot;forward:&#x2F;success&quot;;
    &#125;

    &#x2F;&#x2F;&#x2F;&lt;-----------------主角@RequestAttribute在这个方法
    @ResponseBody
    @GetMapping(&quot;&#x2F;success&quot;)
    public Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,
                       @RequestAttribute(value &#x3D; &quot;code&quot;,required &#x3D; false)Integer code,
                       HttpServletRequest request)&#123;
        Object msg1 &#x3D; request.getAttribute(&quot;msg&quot;);

        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();
        Object hello &#x3D; request.getAttribute(&quot;hello&quot;);
        Object world &#x3D; request.getAttribute(&quot;world&quot;);
        Object message &#x3D; request.getAttribute(&quot;message&quot;);

        map.put(&quot;reqMethod_msg&quot;,msg1);
        map.put(&quot;annotation_msg&quot;,msg);
        map.put(&quot;hello&quot;,hello);
        map.put(&quot;world&quot;,world);
        map.put(&quot;message&quot;,message);

        return map;
    &#125;
&#125;</code></pre>

<h2 id="31、请求处理-MatrixVariable与UrlPathHelper"><a href="#31、请求处理-MatrixVariable与UrlPathHelper" class="headerlink" title="31、请求处理-@MatrixVariable与UrlPathHelper"></a>31、请求处理-@MatrixVariable与UrlPathHelper</h2><ol>
<li><p>语法： 请求路径：<code>/cars/sell;low=34;brand=byd,audi,yd</code></p>
</li>
<li><p>SpringBoot默认是禁用了矩阵变量的功能</p>
<ul>
<li>手动开启：原理。对于路径的处理。UrlPathHelper的removeSemicolonContent设置为false，让其支持矩阵变量的。</li>
</ul>
</li>
<li><p>矩阵变量<strong>必须</strong>有url路径变量才能被解析</p>
</li>
</ol>
<p><strong>手动开启矩阵变量</strong>：</p>
<ul>
<li>实现<code>WebMvcConfigurer</code>接口：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
public class WebConfig implements WebMvcConfigurer &#123;
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) &#123;

        UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();
        &#x2F;&#x2F; 不移除；后面的内容。矩阵变量功能就可以生效
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    &#125;
&#125;</code></pre>

<ul>
<li>创建返回<code>WebMvcConfigurer</code>Bean：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
public class WebConfig&#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;
                        @Override
            public void configurePathMatch(PathMatchConfigurer configurer) &#123;
                UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();
                &#x2F;&#x2F; 不移除；后面的内容。矩阵变量功能就可以生效
                urlPathHelper.setRemoveSemicolonContent(false);
                configurer.setUrlPathHelper(urlPathHelper);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>



<p><strong><code>@MatrixVariable</code>的用例</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
public class ParameterTestController &#123;

    &#x2F;&#x2F;&#x2F;cars&#x2F;sell;low&#x3D;34;brand&#x3D;byd,audi,yd
    @GetMapping(&quot;&#x2F;cars&#x2F;&#123;path&#125;&quot;)
    public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low,
                        @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,
                        @PathVariable(&quot;path&quot;) String path)&#123;
        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();

        map.put(&quot;low&quot;,low);
        map.put(&quot;brand&quot;,brand);
        map.put(&quot;path&quot;,path);
        return map;
    &#125;

    &#x2F;&#x2F; &#x2F;boss&#x2F;1;age&#x3D;20&#x2F;2;age&#x3D;10

    @GetMapping(&quot;&#x2F;boss&#x2F;&#123;bossId&#125;&#x2F;&#123;empId&#125;&quot;)
    public Map boss(@MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;bossId&quot;) Integer bossAge,
                    @MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;empId&quot;) Integer empAge)&#123;
        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();

        map.put(&quot;bossAge&quot;,bossAge);
        map.put(&quot;empAge&quot;,empAge);
        return map;

    &#125;

&#125;</code></pre>



<h2 id="32、请求处理-【源码分析】-各种类型参数解析原理"><a href="#32、请求处理-【源码分析】-各种类型参数解析原理" class="headerlink" title="32、请求处理-【源码分析】-各种类型参数解析原理"></a>32、请求处理-【源码分析】-各种类型参数解析原理</h2><p>这要从<code>DispatcherServlet</code>开始说起：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        HttpServletRequest processedRequest &#x3D; request;
        HandlerExecutionChain mappedHandler &#x3D; null;
        boolean multipartRequestParsed &#x3D; false;

        WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);

        try &#123;
            ModelAndView mv &#x3D; null;
            Exception dispatchException &#x3D; null;

            try &#123;
                processedRequest &#x3D; checkMultipart(request);
                multipartRequestParsed &#x3D; (processedRequest !&#x3D; request);

                &#x2F;&#x2F; Determine handler for the current request.
                mappedHandler &#x3D; getHandler(processedRequest);
                if (mappedHandler &#x3D;&#x3D; null) &#123;
                    noHandlerFound(processedRequest, response);
                    return;
                &#125;

                &#x2F;&#x2F; Determine handler adapter for the current request.
                HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());
                ...</code></pre>

<ul>
<li><code>HandlerMapping</code>中找到能处理请求的<code>Handler</code>（Controller.method()）。</li>
<li>为当前Handler 找一个适配器 <code>HandlerAdapter</code>，用的最多的是<strong>RequestMappingHandlerAdapter</strong>。</li>
<li>适配器执行目标方法并确定方法参数的每一个值。</li>
</ul>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p>默认会加载所有<code>HandlerAdapter</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;

    &#x2F;** Detect all HandlerAdapters or just expect &quot;handlerAdapter&quot; bean?. *&#x2F;
    private boolean detectAllHandlerAdapters &#x3D; true;

    ...
    
    private void initHandlerAdapters(ApplicationContext context) &#123;
        this.handlerAdapters &#x3D; null;

        if (this.detectAllHandlerAdapters) &#123;
            &#x2F;&#x2F; Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
            Map&lt;String, HandlerAdapter&gt; matchingBeans &#x3D;
                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
            if (!matchingBeans.isEmpty()) &#123;
                this.handlerAdapters &#x3D; new ArrayList&lt;&gt;(matchingBeans.values());
                &#x2F;&#x2F; We keep HandlerAdapters in sorted order.
                AnnotationAwareOrderComparator.sort(this.handlerAdapters);
            &#125;
        &#125;
     ...</code></pre>

<p>有这些<code>HandlerAdapter</code>：</p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010047654.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ol start="0">
<li><p>支持方法上标注<code>@RequestMapping</code> </p>
</li>
<li><p>支持函数式编程的</p>
</li>
<li><p>…</p>
</li>
<li><p>…</p>
</li>
</ol>
<h3 id="执行目标方法"><a href="#执行目标方法" class="headerlink" title="执行目标方法"></a>执行目标方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        ModelAndView mv &#x3D; null;
        
        ...

        &#x2F;&#x2F; Determine handler for the current request.
        mappedHandler &#x3D; getHandler(processedRequest);
        if (mappedHandler &#x3D;&#x3D; null) &#123;
            noHandlerFound(processedRequest, response);
            return;
        &#125;

        &#x2F;&#x2F; Determine handler adapter for the current request.
        HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());

        ...
		&#x2F;&#x2F;本节重点
        &#x2F;&#x2F; Actually invoke the handler.
        mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre>

<p><code>HandlerAdapter</code>接口实现类<code>RequestMappingHandlerAdapter</code>（主要用来处理<code>@RequestMapping</code>）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;

    ...
    
    &#x2F;&#x2F;AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter
	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception &#123;

        return handleInternal(request, response, (HandlerMethod) handler);
    &#125;

	@Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;
    	ModelAndView mav;
        &#x2F;&#x2F;handleInternal的核心
        mav &#x3D; invokeHandlerMethod(request, response, handlerMethod);&#x2F;&#x2F;解释看下节
		&#x2F;&#x2F;...
		return mav;
    &#125;
&#125;</code></pre>

<h3 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h3><p>确定将要执行的目标方法的每一个参数的值是什么;</p>
<p>SpringMVC目标方法能写多少种参数类型。取决于<strong>参数解析器argumentResolvers</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

    ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
    try &#123;
        WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);

        ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers !&#x3D; null) &#123;&#x2F;&#x2F;&lt;-----关注点
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        &#125;
        
        ...</code></pre>

<p><code>this.argumentResolvers</code>在<code>afterPropertiesSet()</code>方法内初始化</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
	
    @Nullable
    private HandlerMethodArgumentResolverComposite argumentResolvers;
    
    @Override
    public void afterPropertiesSet() &#123;
        ...
    	if (this.argumentResolvers &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;初始化argumentResolvers
        	List&lt;HandlerMethodArgumentResolver&gt; resolvers &#x3D; getDefaultArgumentResolvers();
            this.argumentResolvers &#x3D; new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
        &#125;
        ...
    &#125;

    &#x2F;&#x2F;初始化了一堆的实现HandlerMethodArgumentResolver接口的
	private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123;
		List&lt;HandlerMethodArgumentResolver&gt; resolvers &#x3D; new ArrayList&lt;&gt;(30);

		&#x2F;&#x2F; Annotation-based argument resolution
		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));
		resolvers.add(new RequestParamMapMethodArgumentResolver());
		resolvers.add(new PathVariableMethodArgumentResolver());
		resolvers.add(new PathVariableMapMethodArgumentResolver());
		resolvers.add(new MatrixVariableMethodArgumentResolver());
		resolvers.add(new MatrixVariableMapMethodArgumentResolver());
		resolvers.add(new ServletModelAttributeMethodProcessor(false));
		resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new RequestHeaderMapMethodArgumentResolver());
		resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new SessionAttributeMethodArgumentResolver());
		resolvers.add(new RequestAttributeMethodArgumentResolver());

		&#x2F;&#x2F; Type-based argument resolution
		resolvers.add(new ServletRequestMethodArgumentResolver());
		resolvers.add(new ServletResponseMethodArgumentResolver());
		resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RedirectAttributesMethodArgumentResolver());
		resolvers.add(new ModelMethodProcessor());
		resolvers.add(new MapMethodProcessor());
		resolvers.add(new ErrorsMethodArgumentResolver());
		resolvers.add(new SessionStatusMethodArgumentResolver());
		resolvers.add(new UriComponentsBuilderMethodArgumentResolver());
		if (KotlinDetector.isKotlinPresent()) &#123;
			resolvers.add(new ContinuationHandlerMethodArgumentResolver());
		&#125;

		&#x2F;&#x2F; Custom arguments
		if (getCustomArgumentResolvers() !&#x3D; null) &#123;
			resolvers.addAll(getCustomArgumentResolvers());
		&#125;

		&#x2F;&#x2F; Catch-all
		resolvers.add(new PrincipalMethodArgumentResolver());
		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));
		resolvers.add(new ServletModelAttributeMethodProcessor(true));

		return resolvers;
	&#125;
    
&#125;</code></pre>

<p><code>HandlerMethodArgumentResolverComposite</code>类如下：（众多<strong>参数解析器argumentResolvers</strong>的包装类）。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123;

	private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers &#x3D; new ArrayList&lt;&gt;();
    
    ...
    
	public HandlerMethodArgumentResolverComposite addResolvers(
			@Nullable HandlerMethodArgumentResolver... resolvers) &#123;

		if (resolvers !&#x3D; null) &#123;
			Collections.addAll(this.argumentResolvers, resolvers);
		&#125;
		return this;
	&#125;
    
    ...
&#125;</code></pre>

<p>我们看看<code>HandlerMethodArgumentResolver</code>的源码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface HandlerMethodArgumentResolver &#123;

    &#x2F;&#x2F;当前解析器是否支持解析这种参数
	boolean supportsParameter(MethodParameter parameter);

	@Nullable&#x2F;&#x2F;如果支持，就调用 resolveArgument
	Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;

&#125;
</code></pre>

<h3 id="返回值处理器"><a href="#返回值处理器" class="headerlink" title="返回值处理器"></a>返回值处理器</h3><p><strong>ValueHandler</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

    ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
    try &#123;
        WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);

        ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers !&#x3D; null) &#123;
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        &#125;
        if (this.returnValueHandlers !&#x3D; null) &#123;&#x2F;&#x2F;&lt;---关注点
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        &#125;
     ...
</code></pre>

<p><code>this.returnValueHandlers</code>在<code>afterPropertiesSet()</code>方法内初始化</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
	
	@Nullable
	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;
    
	@Override
	public void afterPropertiesSet() &#123;

        ...
        
		if (this.returnValueHandlers &#x3D;&#x3D; null) &#123;
			List&lt;HandlerMethodReturnValueHandler&gt; handlers &#x3D; getDefaultReturnValueHandlers();
			this.returnValueHandlers &#x3D; new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
		&#125;
	&#125;
    
    &#x2F;&#x2F;初始化了一堆的实现HandlerMethodReturnValueHandler接口的
    private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123;
		List&lt;HandlerMethodReturnValueHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;(20);

		&#x2F;&#x2F; Single-purpose return value types
		handlers.add(new ModelAndViewMethodReturnValueHandler());
		handlers.add(new ModelMethodProcessor());
		handlers.add(new ViewMethodReturnValueHandler());
		handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(),
				this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager));
		handlers.add(new StreamingResponseBodyReturnValueHandler());
		handlers.add(new HttpEntityMethodProcessor(getMessageConverters(),
				this.contentNegotiationManager, this.requestResponseBodyAdvice));
		handlers.add(new HttpHeadersReturnValueHandler());
		handlers.add(new CallableMethodReturnValueHandler());
		handlers.add(new DeferredResultMethodReturnValueHandler());
		handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));

		&#x2F;&#x2F; Annotation-based return value types
		handlers.add(new ServletModelAttributeMethodProcessor(false));
		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),
				this.contentNegotiationManager, this.requestResponseBodyAdvice));

		&#x2F;&#x2F; Multi-purpose return value types
		handlers.add(new ViewNameMethodReturnValueHandler());
		handlers.add(new MapMethodProcessor());

		&#x2F;&#x2F; Custom return value types
		if (getCustomReturnValueHandlers() !&#x3D; null) &#123;
			handlers.addAll(getCustomReturnValueHandlers());
		&#125;

		&#x2F;&#x2F; Catch-all
		if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;
			handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));
		&#125;
		else &#123;
			handlers.add(new ServletModelAttributeMethodProcessor(true));
		&#125;

		return handlers;
	&#125;
&#125;</code></pre>

<p><code>HandlerMethodReturnValueHandlerComposite</code>类如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler &#123;

	private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers &#x3D; new ArrayList&lt;&gt;();

    ...
    
	public HandlerMethodReturnValueHandlerComposite addHandlers(
			@Nullable List&lt;? extends HandlerMethodReturnValueHandler&gt; handlers) &#123;

		if (handlers !&#x3D; null) &#123;
			this.returnValueHandlers.addAll(handlers);
		&#125;
		return this;
	&#125;

&#125;</code></pre>

<p><code>HandlerMethodReturnValueHandler</code>接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface HandlerMethodReturnValueHandler &#123;

	boolean supportsReturnType(MethodParameter returnType);

	void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;

&#125;</code></pre>

<h3 id="回顾执行目标方法"><a href="#回顾执行目标方法" class="headerlink" title="回顾执行目标方法"></a>回顾执行目标方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    ...
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        ModelAndView mv &#x3D; null;
		...
        mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre>

<p><code>RequestMappingHandlerAdapter</code>的<code>handle()</code>方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;

    ...
    
    &#x2F;&#x2F;AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter
	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception &#123;

        return handleInternal(request, response, (HandlerMethod) handler);
    &#125;

	@Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;
    	ModelAndView mav;
        &#x2F;&#x2F;handleInternal的核心
        mav &#x3D; invokeHandlerMethod(request, response, handlerMethod);&#x2F;&#x2F;解释看下节
		&#x2F;&#x2F;...
		return mav;
    &#125;
&#125;</code></pre>

<p><code>RequestMappingHandlerAdapter</code>的<code>invokeHandlerMethod()</code>方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
    
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

		ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
		try &#123;
			...
            
            ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
			if (this.argumentResolvers !&#x3D; null) &#123;
				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
			&#125;
			if (this.returnValueHandlers !&#x3D; null) &#123;
				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
			&#125;
			...

            &#x2F;&#x2F;关注点：执行目标方法
			invocableMethod.invokeAndHandle(webRequest, mavContainer);
			if (asyncManager.isConcurrentHandlingStarted()) &#123;
				return null;
			&#125;

			return getModelAndView(mavContainer, modelFactory, webRequest);
		&#125;
		finally &#123;
			webRequest.requestCompleted();
		&#125;
	&#125;</code></pre>

<p><code>invokeAndHandle()</code>方法如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123;

	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

		Object returnValue &#x3D; invokeForRequest(webRequest, mavContainer, providedArgs);

        ...
        
		try &#123;
            &#x2F;&#x2F;returnValue存储起来
			this.returnValueHandlers.handleReturnValue(
					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
		&#125;
		catch (Exception ex) &#123;
			...
		&#125;
	&#125;
    
    @Nullable&#x2F;&#x2F;InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类
	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

        &#x2F;&#x2F;&#x2F;&#x2F;获取方法的参数值
		Object[] args &#x3D; getMethodArgumentValues(request, mavContainer, providedArgs);

        ...
       
		return doInvoke(args);
	&#125;

    @Nullable
	protected Object doInvoke(Object... args) throws Exception &#123;
		Method method &#x3D; getBridgedMethod();&#x2F;&#x2F;@RequestMapping的方法
		ReflectionUtils.makeAccessible(method);
		try &#123;
			if (KotlinDetector.isSuspendingFunction(method)) &#123;
				return CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);
			&#125;
            &#x2F;&#x2F;通过反射调用
			return method.invoke(getBean(), args);&#x2F;&#x2F;getBean()指@RequestMapping的方法所在类的对象。
		&#125;
		catch (IllegalArgumentException ex) &#123;
			...
		&#125;
		catch (InvocationTargetException ex) &#123;
			...
		&#125;
	&#125;
    
&#125;   </code></pre>



<h3 id="如何确定目标方法每一个参数的值"><a href="#如何确定目标方法每一个参数的值" class="headerlink" title="如何确定目标方法每一个参数的值"></a>如何确定目标方法每一个参数的值</h3><p>重点分析<code>ServletInvocableHandlerMethod</code>的<code>getMethodArgumentValues</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123;
    ...

	@Nullable&#x2F;&#x2F;InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类
	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

        &#x2F;&#x2F;&#x2F;&#x2F;获取方法的参数值
		Object[] args &#x3D; getMethodArgumentValues(request, mavContainer, providedArgs);

        ...
       
		return doInvoke(args);
	&#125;
 
    &#x2F;&#x2F;本节重点，获取方法的参数值
	protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

		MethodParameter[] parameters &#x3D; getMethodParameters();
		if (ObjectUtils.isEmpty(parameters)) &#123;
			return EMPTY_ARGS;
		&#125;

		Object[] args &#x3D; new Object[parameters.length];
		for (int i &#x3D; 0; i &lt; parameters.length; i++) &#123;
			MethodParameter parameter &#x3D; parameters[i];
			parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
			args[i] &#x3D; findProvidedArgument(parameter, providedArgs);
			if (args[i] !&#x3D; null) &#123;
				continue;
			&#125;
            &#x2F;&#x2F;查看resolvers是否有支持
			if (!this.resolvers.supportsParameter(parameter)) &#123;
				throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));
			&#125;
			try &#123;
                &#x2F;&#x2F;支持的话就开始解析吧
				args[i] &#x3D; this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
			&#125;
			catch (Exception ex) &#123;
				....
			&#125;
		&#125;
		return args;
	&#125;
    
&#125;</code></pre>

<p><code>this.resolvers</code>的类型为<code>HandlerMethodArgumentResolverComposite</code>（在<a href="#">参数解析器</a>章节提及）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123;
    
	@Override
	public boolean supportsParameter(MethodParameter parameter) &#123;
		return getArgumentResolver(parameter) !&#x3D; null;
	&#125;

	@Override
	@Nullable
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		HandlerMethodArgumentResolver resolver &#x3D; getArgumentResolver(parameter);
		if (resolver &#x3D;&#x3D; null) &#123;
			throw new IllegalArgumentException(&quot;Unsupported parameter type [&quot; +
					parameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;);
		&#125;
		return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
	&#125;
    
    
    @Nullable
	private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;
		HandlerMethodArgumentResolver result &#x3D; this.argumentResolverCache.get(parameter);
		if (result &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F;挨个判断所有参数解析器那个支持解析这个参数
			for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;
				if (resolver.supportsParameter(parameter)) &#123;
					result &#x3D; resolver;
					this.argumentResolverCache.put(parameter, result);&#x2F;&#x2F;找到了，resolver就缓存起来，方便稍后resolveArgument()方法使用
					break;
				&#125;
			&#125;
		&#125;
		return result;
	&#125;
&#125;</code></pre>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本节描述，一个请求发送到DispatcherServlet后的具体处理流程，也就是SpringMVC的主要原理。</p>
<p>本节内容较多且硬核，对日后编程很有帮助，需耐心对待。</p>
<p>可以运行一个示例，打断点，在Debug模式下，查看程序流程。</p>
<h2 id="33、请求处理-【源码分析】-Servlet-API参数解析原理"><a href="#33、请求处理-【源码分析】-Servlet-API参数解析原理" class="headerlink" title="33、请求处理-【源码分析】-Servlet API参数解析原理"></a>33、请求处理-【源码分析】-Servlet API参数解析原理</h2><ul>
<li>WebRequest</li>
<li>ServletRequest</li>
<li>MultipartRequest</li>
<li>HttpSession</li>
<li>javax.servlet.http.PushBuilder</li>
<li>Principal</li>
<li>InputStream</li>
<li>Reader</li>
<li>HttpMethod</li>
<li>Locale</li>
<li>TimeZone</li>
<li>ZoneId</li>
</ul>
<p><strong>ServletRequestMethodArgumentResolver</strong>用来处理以上的参数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletRequestMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;

	@Nullable
	private static Class&lt;?&gt; pushBuilder;

	static &#123;
		try &#123;
			pushBuilder &#x3D; ClassUtils.forName(&quot;javax.servlet.http.PushBuilder&quot;,
					ServletRequestMethodArgumentResolver.class.getClassLoader());
		&#125;
		catch (ClassNotFoundException ex) &#123;
			&#x2F;&#x2F; Servlet 4.0 PushBuilder not found - not supported for injection
			pushBuilder &#x3D; null;
		&#125;
	&#125;


	@Override
	public boolean supportsParameter(MethodParameter parameter) &#123;
		Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();
		return (WebRequest.class.isAssignableFrom(paramType) ||
				ServletRequest.class.isAssignableFrom(paramType) ||
				MultipartRequest.class.isAssignableFrom(paramType) ||
				HttpSession.class.isAssignableFrom(paramType) ||
				(pushBuilder !&#x3D; null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||
				(Principal.class.isAssignableFrom(paramType) &amp;&amp; !parameter.hasParameterAnnotations()) ||
				InputStream.class.isAssignableFrom(paramType) ||
				Reader.class.isAssignableFrom(paramType) ||
				HttpMethod.class &#x3D;&#x3D; paramType ||
				Locale.class &#x3D;&#x3D; paramType ||
				TimeZone.class &#x3D;&#x3D; paramType ||
				ZoneId.class &#x3D;&#x3D; paramType);
	&#125;

	@Override
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();

		&#x2F;&#x2F; WebRequest &#x2F; NativeWebRequest &#x2F; ServletWebRequest
		if (WebRequest.class.isAssignableFrom(paramType)) &#123;
			if (!paramType.isInstance(webRequest)) &#123;
				throw new IllegalStateException(
						&quot;Current request is not of type [&quot; + paramType.getName() + &quot;]: &quot; + webRequest);
			&#125;
			return webRequest;
		&#125;

		&#x2F;&#x2F; ServletRequest &#x2F; HttpServletRequest &#x2F; MultipartRequest &#x2F; MultipartHttpServletRequest
		if (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) &#123;
			return resolveNativeRequest(webRequest, paramType);
		&#125;

		&#x2F;&#x2F; HttpServletRequest required for all further argument types
		return resolveArgument(paramType, resolveNativeRequest(webRequest, HttpServletRequest.class));
	&#125;

	private &lt;T&gt; T resolveNativeRequest(NativeWebRequest webRequest, Class&lt;T&gt; requiredType) &#123;
		T nativeRequest &#x3D; webRequest.getNativeRequest(requiredType);
		if (nativeRequest &#x3D;&#x3D; null) &#123;
			throw new IllegalStateException(
					&quot;Current request is not of type [&quot; + requiredType.getName() + &quot;]: &quot; + webRequest);
		&#125;
		return nativeRequest;
	&#125;

	@Nullable
	private Object resolveArgument(Class&lt;?&gt; paramType, HttpServletRequest request) throws IOException &#123;
		if (HttpSession.class.isAssignableFrom(paramType)) &#123;
			HttpSession session &#x3D; request.getSession();
			if (session !&#x3D; null &amp;&amp; !paramType.isInstance(session)) &#123;
				throw new IllegalStateException(
						&quot;Current session is not of type [&quot; + paramType.getName() + &quot;]: &quot; + session);
			&#125;
			return session;
		&#125;
		else if (pushBuilder !&#x3D; null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) &#123;
			return PushBuilderDelegate.resolvePushBuilder(request, paramType);
		&#125;
		else if (InputStream.class.isAssignableFrom(paramType)) &#123;
			InputStream inputStream &#x3D; request.getInputStream();
			if (inputStream !&#x3D; null &amp;&amp; !paramType.isInstance(inputStream)) &#123;
				throw new IllegalStateException(
						&quot;Request input stream is not of type [&quot; + paramType.getName() + &quot;]: &quot; + inputStream);
			&#125;
			return inputStream;
		&#125;
		else if (Reader.class.isAssignableFrom(paramType)) &#123;
			Reader reader &#x3D; request.getReader();
			if (reader !&#x3D; null &amp;&amp; !paramType.isInstance(reader)) &#123;
				throw new IllegalStateException(
						&quot;Request body reader is not of type [&quot; + paramType.getName() + &quot;]: &quot; + reader);
			&#125;
			return reader;
		&#125;
		else if (Principal.class.isAssignableFrom(paramType)) &#123;
			Principal userPrincipal &#x3D; request.getUserPrincipal();
			if (userPrincipal !&#x3D; null &amp;&amp; !paramType.isInstance(userPrincipal)) &#123;
				throw new IllegalStateException(
						&quot;Current user principal is not of type [&quot; + paramType.getName() + &quot;]: &quot; + userPrincipal);
			&#125;
			return userPrincipal;
		&#125;
		else if (HttpMethod.class &#x3D;&#x3D; paramType) &#123;
			return HttpMethod.resolve(request.getMethod());
		&#125;
		else if (Locale.class &#x3D;&#x3D; paramType) &#123;
			return RequestContextUtils.getLocale(request);
		&#125;
		else if (TimeZone.class &#x3D;&#x3D; paramType) &#123;
			TimeZone timeZone &#x3D; RequestContextUtils.getTimeZone(request);
			return (timeZone !&#x3D; null ? timeZone : TimeZone.getDefault());
		&#125;
		else if (ZoneId.class &#x3D;&#x3D; paramType) &#123;
			TimeZone timeZone &#x3D; RequestContextUtils.getTimeZone(request);
			return (timeZone !&#x3D; null ? timeZone.toZoneId() : ZoneId.systemDefault());
		&#125;

		&#x2F;&#x2F; Should never happen...
		throw new UnsupportedOperationException(&quot;Unknown parameter type: &quot; + paramType.getName());
	&#125;


	&#x2F;**
	 * Inner class to avoid a hard dependency on Servlet API 4.0 at runtime.
	 *&#x2F;
	private static class PushBuilderDelegate &#123;

		@Nullable
		public static Object resolvePushBuilder(HttpServletRequest request, Class&lt;?&gt; paramType) &#123;
			PushBuilder pushBuilder &#x3D; request.newPushBuilder();
			if (pushBuilder !&#x3D; null &amp;&amp; !paramType.isInstance(pushBuilder)) &#123;
				throw new IllegalStateException(
						&quot;Current push builder is not of type [&quot; + paramType.getName() + &quot;]: &quot; + pushBuilder);
			&#125;
			return pushBuilder;

		&#125;
	&#125;
&#125;</code></pre>

<p>用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class RequestController &#123;

    @GetMapping(&quot;&#x2F;goto&quot;)
    public String goToPage(HttpServletRequest request)&#123;

        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);
        request.setAttribute(&quot;code&quot;,200);
        return &quot;forward:&#x2F;success&quot;;  &#x2F;&#x2F;转发到  &#x2F;success请求
    &#125;
&#125;</code></pre>

<h2 id="34、请求处理-【源码分析】-Model、Map原理"><a href="#34、请求处理-【源码分析】-Model、Map原理" class="headerlink" title="34、请求处理-【源码分析】-Model、Map原理"></a>34、请求处理-【源码分析】-Model、Map原理</h2><p>复杂参数：</p>
<ul>
<li><p><strong>Map</strong></p>
</li>
<li><p><strong>Model（map、model里面的数据会被放在request的请求域  request.setAttribute）</strong></p>
</li>
<li><p>Errors&#x2F;BindingResult</p>
</li>
<li><p><strong>RedirectAttributes（ 重定向携带数据）</strong></p>
</li>
<li><p><strong>ServletResponse（response）</strong></p>
</li>
<li><p>SessionStatus</p>
</li>
<li><p>UriComponentsBuilder</p>
</li>
<li><p>ServletUriComponentsBuilder</p>
</li>
</ul>
<p>用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;params&quot;)
public String testParam(Map&lt;String,Object&gt; map,
                        Model model,
                        HttpServletRequest request,
                        HttpServletResponse response)&#123;
    &#x2F;&#x2F;下面三位都是可以给request域中放数据
    map.put(&quot;hello&quot;,&quot;world666&quot;);
    model.addAttribute(&quot;world&quot;,&quot;hello666&quot;);
    request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;);

    Cookie cookie &#x3D; new Cookie(&quot;c1&quot;,&quot;v1&quot;);
    response.addCookie(cookie);
    return &quot;forward:&#x2F;success&quot;;
&#125;

@ResponseBody
@GetMapping(&quot;&#x2F;success&quot;)
public Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,
                   @RequestAttribute(value &#x3D; &quot;code&quot;,required &#x3D; false)Integer code,
                   HttpServletRequest request)&#123;
    Object msg1 &#x3D; request.getAttribute(&quot;msg&quot;);

    Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();
    Object hello &#x3D; request.getAttribute(&quot;hello&quot;);&#x2F;&#x2F;得出testParam方法赋予的值 world666
    Object world &#x3D; request.getAttribute(&quot;world&quot;);&#x2F;&#x2F;得出testParam方法赋予的值 hello666
    Object message &#x3D; request.getAttribute(&quot;message&quot;);&#x2F;&#x2F;得出testParam方法赋予的值 HelloWorld

    map.put(&quot;reqMethod_msg&quot;,msg1);
    map.put(&quot;annotation_msg&quot;,msg);
    map.put(&quot;hello&quot;,hello);
    map.put(&quot;world&quot;,world);
    map.put(&quot;message&quot;,message);

    return map;
&#125;</code></pre>

<ul>
<li><p><code>Map&lt;String,Object&gt; map</code></p>
</li>
<li><p><code>Model model</code></p>
</li>
<li><p><code>HttpServletRequest request</code></p>
</li>
</ul>
<p>上面三位都是可以给request域中放数据，用<code>request.getAttribute()</code>获取</p>
<p>接下来我们看看，<code>Map&lt;String,Object&gt; map</code>与<code>Model model</code>用什么参数处理器。</p>
<hr>
<p><code>Map&lt;String,Object&gt; map</code>参数用<code>MapMethodProcessor</code>处理：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler &#123;

	@Override
	public boolean supportsParameter(MethodParameter parameter) &#123;
		return (Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;
				parameter.getParameterAnnotations().length &#x3D;&#x3D; 0);
	&#125;

	@Override
	@Nullable
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		Assert.state(mavContainer !&#x3D; null, &quot;ModelAndViewContainer is required for model exposure&quot;);
		return mavContainer.getModel();
	&#125;
    
    ...
    
&#125;</code></pre>

<p><code>mavContainer.getModel()</code>如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ModelAndViewContainer &#123;

    ...

	private final ModelMap defaultModel &#x3D; new BindingAwareModelMap();

	@Nullable
	private ModelMap redirectModel;

    ...

	public ModelMap getModel() &#123;
		if (useDefaultModel()) &#123;
			return this.defaultModel;
		&#125;
		else &#123;
			if (this.redirectModel &#x3D;&#x3D; null) &#123;
				this.redirectModel &#x3D; new ModelMap();
			&#125;
			return this.redirectModel;
		&#125;
	&#125;
    
    private boolean useDefaultModel() &#123;
		return (!this.redirectModelScenario || (this.redirectModel &#x3D;&#x3D; null &amp;&amp; !this.ignoreDefaultModelOnRedirect));
	&#125;
    ...
    
&#125;</code></pre>

<hr>
<p><code>Model model</code>用<code>ModelMethodProcessor</code>处理：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ModelMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler &#123;

	@Override
	public boolean supportsParameter(MethodParameter parameter) &#123;
		return Model.class.isAssignableFrom(parameter.getParameterType());
	&#125;

	@Override
	@Nullable
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		Assert.state(mavContainer !&#x3D; null, &quot;ModelAndViewContainer is required for model exposure&quot;);
		return mavContainer.getModel();
	&#125;
    ...
&#125;</code></pre>

<p><code>return mavContainer.getModel();</code>这跟<code>MapMethodProcessor</code>的一致</p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010247689.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><code>Model</code>也是另一种意义的<code>Map</code>。</p>
<hr>
<p><strong>接下来看看</strong><code>Map&lt;String,Object&gt; map</code>与<code>Model model</code>值是如何做到用<code>request.getAttribute()</code>获取的。</p>
<p>众所周知，所有的数据都放在 <strong>ModelAndView</strong>包含要去的页面地址View，还包含Model数据。</p>
<p>先看<strong>ModelAndView</strong>接下来是如何处理的？</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
    ...
    
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		...

		try &#123;
			ModelAndView mv &#x3D; null;
            
            ...

			&#x2F;&#x2F; Actually invoke the handler.
			mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());
            
            ...
            
			&#125;
			catch (Exception ex) &#123;
				dispatchException &#x3D; ex;
			&#125;
			catch (Throwable err) &#123;
				&#x2F;&#x2F; As of 4.3, we&#39;re processing Errors thrown from handler methods as well,
				&#x2F;&#x2F; making them available for @ExceptionHandler methods and other scenarios.
				dispatchException &#x3D; new NestedServletException(&quot;Handler dispatch failed&quot;, err);
			&#125;
        	&#x2F;&#x2F;处理分发结果
			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		&#125;
        ...

	&#125;

	private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception &#123;
        ...

		&#x2F;&#x2F; Did the handler return a view to render?
		if (mv !&#x3D; null &amp;&amp; !mv.wasCleared()) &#123;
			render(mv, request, response);
			...
		&#125;
		...
	&#125;

	protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		...

		View view;
		String viewName &#x3D; mv.getViewName();
		if (viewName !&#x3D; null) &#123;
			&#x2F;&#x2F; We need to resolve the view name.
			view &#x3D; resolveViewName(viewName, mv.getModelInternal(), locale, request);
			if (view &#x3D;&#x3D; null) &#123;
				throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +
						&quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
			&#125;
		&#125;
		else &#123;
			&#x2F;&#x2F; No need to lookup: the ModelAndView object contains the actual View object.
			view &#x3D; mv.getView();
			if (view &#x3D;&#x3D; null) &#123;
				throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
						&quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
			&#125;
		&#125;
		view.render(mv.getModelInternal(), request, response);
        
        ...
	&#125;

&#125;</code></pre>

<p>在Debug模式下，<code>view</code>属为<code>InternalResourceView</code>类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class InternalResourceView extends AbstractUrlBasedView &#123;
    
 	@Override&#x2F;&#x2F;该方法在AbstractView，AbstractUrlBasedView继承了AbstractView
	public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,
			HttpServletResponse response) throws Exception &#123;
		
        ...
        
		Map&lt;String, Object&gt; mergedModel &#x3D; createMergedOutputModel(model, request, response);
		prepareResponse(request, response);
        
        &#x2F;&#x2F;看下一个方法实现
		renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
	&#125;
    
    @Override
	protected void renderMergedOutputModel(
			Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;

		&#x2F;&#x2F; Expose the model object as request attributes.
        &#x2F;&#x2F; 暴露模型作为请求域属性
		exposeModelAsRequestAttributes(model, request);&#x2F;&#x2F;&lt;---重点

		&#x2F;&#x2F; Expose helpers as request attributes, if any.
		exposeHelpers(request);

		&#x2F;&#x2F; Determine the path for the request dispatcher.
		String dispatcherPath &#x3D; prepareForRendering(request, response);

		&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).
		RequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);
		
        ...
	&#125;
    
    &#x2F;&#x2F;该方法在AbstractView，AbstractUrlBasedView继承了AbstractView
    protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model,
			HttpServletRequest request) throws Exception &#123;

		model.forEach((name, value) -&gt; &#123;
			if (value !&#x3D; null) &#123;
				request.setAttribute(name, value);
			&#125;
			else &#123;
				request.removeAttribute(name);
			&#125;
		&#125;);
	&#125;
    
&#125;</code></pre>

<p><code>exposeModelAsRequestAttributes</code>方法看出，<code>Map&lt;String,Object&gt; map</code>，<code>Model model</code>这两种类型数据可以给request域中放数据，用<code>request.getAttribute()</code>获取。</p>
<h2 id="35、请求处理-【源码分析】-自定义参数绑定原理"><a href="#35、请求处理-【源码分析】-自定义参数绑定原理" class="headerlink" title="35、请求处理-【源码分析】-自定义参数绑定原理"></a>35、请求处理-【源码分析】-自定义参数绑定原理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
public class ParameterTestController &#123;

    &#x2F;**
     * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定
     * @param person
     * @return
     *&#x2F;
    @PostMapping(&quot;&#x2F;saveuser&quot;)
    public Person saveuser(Person person)&#123;
        return person;
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 *     姓名： &lt;input name&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;br&#x2F;&gt;
 *     年龄： &lt;input name&#x3D;&quot;age&quot;&#x2F;&gt; &lt;br&#x2F;&gt;
 *     生日： &lt;input name&#x3D;&quot;birth&quot;&#x2F;&gt; &lt;br&#x2F;&gt;
 *     宠物姓名：&lt;input name&#x3D;&quot;pet.name&quot;&#x2F;&gt;&lt;br&#x2F;&gt;
 *     宠物年龄：&lt;input name&#x3D;&quot;pet.age&quot;&#x2F;&gt;
 *&#x2F;
@Data
public class Person &#123;
    
    private String userName;
    private Integer age;
    private Date birth;
    private Pet pet;
    
&#125;

@Data
public class Pet &#123;

    private String name;
    private String age;

&#125;</code></pre>

<p>封装过程用到<code>ServletModelAttributeMethodProcessor</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletModelAttributeMethodProcessor extends ModelAttributeMethodProcessor &#123;
	
    @Override&#x2F;&#x2F;本方法在ModelAttributeMethodProcessor类，
	public boolean supportsParameter(MethodParameter parameter) &#123;
		return (parameter.hasParameterAnnotation(ModelAttribute.class) ||
				(this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));
	&#125;

	@Override
	@Nullable&#x2F;&#x2F;本方法在ModelAttributeMethodProcessor类，
	public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		...

		String name &#x3D; ModelFactory.getNameForParameter(parameter);
		ModelAttribute ann &#x3D; parameter.getParameterAnnotation(ModelAttribute.class);
		if (ann !&#x3D; null) &#123;
			mavContainer.setBinding(name, ann.binding());
		&#125;

		Object attribute &#x3D; null;
		BindingResult bindingResult &#x3D; null;

		if (mavContainer.containsAttribute(name)) &#123;
			attribute &#x3D; mavContainer.getModel().get(name);
		&#125;
		else &#123;
			&#x2F;&#x2F; Create attribute instance
			try &#123;
				attribute &#x3D; createAttribute(name, parameter, binderFactory, webRequest);
			&#125;
			catch (BindException ex) &#123;
				...
			&#125;
		&#125;

		if (bindingResult &#x3D;&#x3D; null) &#123;
			&#x2F;&#x2F; Bean property binding and validation;
			&#x2F;&#x2F; skipped in case of binding failure on construction.
			WebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);
			if (binder.getTarget() !&#x3D; null) &#123;
				if (!mavContainer.isBindingDisabled(name)) &#123;
                    &#x2F;&#x2F;web数据绑定器，将请求参数的值绑定到指定的JavaBean里面**
					bindRequestParameters(binder, webRequest);
				&#125;
				validateIfApplicable(binder, parameter);
				if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;
					throw new BindException(binder.getBindingResult());
				&#125;
			&#125;
			&#x2F;&#x2F; Value type adaptation, also covering java.util.Optional
			if (!parameter.getParameterType().isInstance(attribute)) &#123;
				attribute &#x3D; binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
			&#125;
			bindingResult &#x3D; binder.getBindingResult();
		&#125;

		&#x2F;&#x2F; Add resolved attribute and BindingResult at the end of the model
		Map&lt;String, Object&gt; bindingResultModel &#x3D; bindingResult.getModel();
		mavContainer.removeAttributes(bindingResultModel);
		mavContainer.addAllAttributes(bindingResultModel);

		return attribute;
	&#125;
&#125;</code></pre>

<p><strong>WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中</strong></p>
<p><strong>在过程当中，用到GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型</strong></p>
<h2 id="36、请求处理-【源码分析】-自定义Converter原理"><a href="#36、请求处理-【源码分析】-自定义Converter原理" class="headerlink" title="36、请求处理-【源码分析】-自定义Converter原理"></a>36、请求处理-【源码分析】-自定义Converter原理</h2><p>未来我们可以给WebDataBinder里面放自己的Converter；</p>
<p>下面演示将字符串<code>“啊猫,3”</code>转换成<code>Pet</code>对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;1、WebMvcConfigurer定制化SpringMVC的功能
@Bean
public WebMvcConfigurer webMvcConfigurer()&#123;
    return new WebMvcConfigurer() &#123;

        @Override
        public void addFormatters(FormatterRegistry registry) &#123;
            registry.addConverter(new Converter&lt;String, Pet&gt;() &#123;

                @Override
                public Pet convert(String source) &#123;
                    &#x2F;&#x2F; 啊猫,3
                    if(!StringUtils.isEmpty(source))&#123;
                        Pet pet &#x3D; new Pet();
                        String[] split &#x3D; source.split(&quot;,&quot;);
                        pet.setName(split[0]);
                        pet.setAge(Integer.parseInt(split[1]));
                        return pet;
                    &#125;
                    return null;
                &#125;
            &#125;);
        &#125;
    &#125;;
&#125;</code></pre>



<h2 id="37、响应处理-【源码分析】-ReturnValueHandler原理"><a href="#37、响应处理-【源码分析】-ReturnValueHandler原理" class="headerlink" title="37、响应处理-【源码分析】-ReturnValueHandler原理"></a>37、响应处理-【源码分析】-ReturnValueHandler原理</h2><p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010403920.jpg" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>假设给前端自动返回json数据，需要引入相关的依赖</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;

&lt;!-- web场景自动引入了json场景 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-json&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;
    &lt;scope&gt;compile&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>控制层代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class ResponseTestController &#123;
    
	@ResponseBody  &#x2F;&#x2F;利用返回值处理器里面的消息转换器进行处理
    @GetMapping(value &#x3D; &quot;&#x2F;test&#x2F;person&quot;)
    public Person getPerson()&#123;
        Person person &#x3D; new Person();
        person.setAge(28);
        person.setBirth(new Date());
        person.setUserName(&quot;zhangsan&quot;);
        return person;
    &#125;

&#125;</code></pre>

<p><a href="#">32、请求处理-【源码分析】-各种类型参数解析原理 - 返回值处理器</a>有讨论<strong>ReturnValueHandler</strong>。现在直接看看重点：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;

    ...
    
	@Nullable
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

		ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
		try &#123;
			
            ...
            
            ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
                
			if (this.argumentResolvers !&#x3D; null) &#123;
				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
			&#125;
			if (this.returnValueHandlers !&#x3D; null) &#123;&#x2F;&#x2F;&lt;----关注点
				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
			&#125;

            ...

			invocableMethod.invokeAndHandle(webRequest, mavContainer);&#x2F;&#x2F;看下块代码
			if (asyncManager.isConcurrentHandlingStarted()) &#123;
				return null;
			&#125;

			return getModelAndView(mavContainer, modelFactory, webRequest);
		&#125;
		finally &#123;
			webRequest.requestCompleted();
		&#125;
	&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123;
    
	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

		Object returnValue &#x3D; invokeForRequest(webRequest, mavContainer, providedArgs);
		
        ...
        
		try &#123;
            &#x2F;&#x2F;看下块代码
			this.returnValueHandlers.handleReturnValue(
					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
		&#125;
		catch (Exception ex) &#123;
			...
		&#125;
	&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler &#123;
    
    ...
    
	@Override
	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;

        &#x2F;&#x2F;selectHandler()实现在下面
		HandlerMethodReturnValueHandler handler &#x3D; selectHandler(returnValue, returnType);
		if (handler &#x3D;&#x3D; null) &#123;
			throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
		&#125;
        &#x2F;&#x2F;开始处理
		handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
	&#125;
    
   	@Nullable
	private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) &#123;
		boolean isAsyncValue &#x3D; isAsyncReturnValue(value, returnType);
		for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123;
			if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123;
				continue;
			&#125;
			if (handler.supportsReturnType(returnType)) &#123;
				return handler;
			&#125;
		&#125;
		return null;
	&#125;
    </code></pre>



<p><code>@ResponseBody</code> 注解，即<code>RequestResponseBodyMethodProcessor</code>，它实现<code>HandlerMethodReturnValueHandler</code>接口</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor &#123;

    ...
    
	@Override
	public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
			throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;

		mavContainer.setRequestHandled(true);
		ServletServerHttpRequest inputMessage &#x3D; createInputMessage(webRequest);
		ServletServerHttpResponse outputMessage &#x3D; createOutputMessage(webRequest);

        &#x2F;&#x2F; 使用消息转换器进行写出操作，本方法下一章节介绍：
		&#x2F;&#x2F; Try even with null return value. ResponseBodyAdvice could get involved.
		writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
	&#125;

&#125;
</code></pre>



<h2 id="38、响应处理-【源码分析】-HTTPMessageConverter原理"><a href="#38、响应处理-【源码分析】-HTTPMessageConverter原理" class="headerlink" title="38、响应处理-【源码分析】-HTTPMessageConverter原理"></a>38、响应处理-【源码分析】-HTTPMessageConverter原理</h2><p>返回值处理器<code>ReturnValueHandler</code>原理：</p>
<ol>
<li>返回值处理器判断是否支持这种类型返回值 <code>supportsReturnType</code></li>
<li>返回值处理器调用 <code>handleReturnValue</code> 进行处理</li>
<li><code>RequestResponseBodyMethodProcessor</code> 可以处理返回值标了<code>@ResponseBody</code> 注解的。<ul>
<li>利用 <code>MessageConverters</code> 进行处理 将数据写为json<ol>
<li>内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）</li>
<li>服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，</li>
<li>SpringMVC会挨个遍历所有容器底层的 <code>HttpMessageConverter</code> ，看谁能处理？<ol>
<li>得到<code>MappingJackson2HttpMessageConverter</code>可以将对象写为json</li>
<li>利用<code>MappingJackson2HttpMessageConverter</code>将对象转为json再写出去。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;RequestResponseBodyMethodProcessor继承这类
public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver
		implements HandlerMethodReturnValueHandler &#123;

    ...
    
    &#x2F;&#x2F;承接上一节内容
    protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,
                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;

            Object body;
            Class&lt;?&gt; valueType;
            Type targetType;

            if (value instanceof CharSequence) &#123;
                body &#x3D; value.toString();
                valueType &#x3D; String.class;
                targetType &#x3D; String.class;
            &#125;
            else &#123;
                body &#x3D; value;
                valueType &#x3D; getReturnValueType(body, returnType);
                targetType &#x3D; GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());
            &#125;

			...

            &#x2F;&#x2F;内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）
            MediaType selectedMediaType &#x3D; null;
            MediaType contentType &#x3D; outputMessage.getHeaders().getContentType();
            boolean isContentTypePreset &#x3D; contentType !&#x3D; null &amp;&amp; contentType.isConcrete();
            if (isContentTypePreset) &#123;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Found &#39;Content-Type:&quot; + contentType + &quot;&#39; in response&quot;);
                &#125;
                selectedMediaType &#x3D; contentType;
            &#125;
            else &#123;
                HttpServletRequest request &#x3D; inputMessage.getServletRequest();
                List&lt;MediaType&gt; acceptableTypes &#x3D; getAcceptableMediaTypes(request);
                &#x2F;&#x2F;服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据
                List&lt;MediaType&gt; producibleTypes &#x3D; getProducibleMediaTypes(request, valueType, targetType);

                if (body !&#x3D; null &amp;&amp; producibleTypes.isEmpty()) &#123;
                    throw new HttpMessageNotWritableException(
                            &quot;No converter found for return value of type: &quot; + valueType);
                &#125;
                List&lt;MediaType&gt; mediaTypesToUse &#x3D; new ArrayList&lt;&gt;();
                for (MediaType requestedType : acceptableTypes) &#123;
                    for (MediaType producibleType : producibleTypes) &#123;
                        if (requestedType.isCompatibleWith(producibleType)) &#123;
                            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));
                        &#125;
                    &#125;
                &#125;
                if (mediaTypesToUse.isEmpty()) &#123;
                    if (body !&#x3D; null) &#123;
                        throw new HttpMediaTypeNotAcceptableException(producibleTypes);
                    &#125;
                    if (logger.isDebugEnabled()) &#123;
                        logger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes);
                    &#125;
                    return;
                &#125;

                MediaType.sortBySpecificityAndQuality(mediaTypesToUse);

                &#x2F;&#x2F;选择一个MediaType
                for (MediaType mediaType : mediaTypesToUse) &#123;
                    if (mediaType.isConcrete()) &#123;
                        selectedMediaType &#x3D; mediaType;
                        break;
                    &#125;
                    else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;
                        selectedMediaType &#x3D; MediaType.APPLICATION_OCTET_STREAM;
                        break;
                    &#125;
                &#125;

                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Using &#39;&quot; + selectedMediaType + &quot;&#39;, given &quot; +
                            acceptableTypes + &quot; and supported &quot; + producibleTypes);
                &#125;
            &#125;

        	
            if (selectedMediaType !&#x3D; null) &#123;
                selectedMediaType &#x3D; selectedMediaType.removeQualityValue();
                &#x2F;&#x2F;本节主角：HttpMessageConverter
                for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123;
                    GenericHttpMessageConverter genericConverter &#x3D; (converter instanceof GenericHttpMessageConverter ?
                            (GenericHttpMessageConverter&lt;?&gt;) converter : null);
                    
                    &#x2F;&#x2F;判断是否可写
                    if (genericConverter !&#x3D; null ?
                            ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :
                            converter.canWrite(valueType, selectedMediaType)) &#123;
                        body &#x3D; getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
                                (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),
                                inputMessage, outputMessage);
                        if (body !&#x3D; null) &#123;
                            Object theBody &#x3D; body;
                            LogFormatUtils.traceDebug(logger, traceOn -&gt;
                                    &quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);
                            addContentDispositionHeader(inputMessage, outputMessage);
							&#x2F;&#x2F;开始写入
                            if (genericConverter !&#x3D; null) &#123;
                                genericConverter.write(body, targetType, selectedMediaType, outputMessage);
                            &#125;
                            else &#123;
                                ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);
                            &#125;
                        &#125;
                        else &#123;
                            if (logger.isDebugEnabled()) &#123;
                                logger.debug(&quot;Nothing to write: null body&quot;);
                            &#125;
                        &#125;
                        return;
                    &#125;
                &#125;
            &#125;
			...
        &#125;</code></pre>

<p><code>HTTPMessageConverter</code>接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Strategy interface for converting from and to HTTP requests and responses.
 *&#x2F;
public interface HttpMessageConverter&lt;T&gt; &#123;

	&#x2F;**
	 * Indicates whether the given class can be read by this converter.
	 *&#x2F;
	boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);

	&#x2F;**
	 * Indicates whether the given class can be written by this converter.
	 *&#x2F;
	boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);

	&#x2F;**
	 * Return the list of &#123;@link MediaType&#125; objects supported by this converter.
	 *&#x2F;
	List&lt;MediaType&gt; getSupportedMediaTypes();

	&#x2F;**
	 * Read an object of the given type from the given input message, and returns it.
	 *&#x2F;
	T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

	&#x2F;**
	 * Write an given object to the given output message.
	 *&#x2F;
	void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

&#125;
</code></pre>

<p><code>HttpMessageConverter</code>: 看是否支持将 此 <code>Class</code>类型的对象，转为<code>MediaType</code>类型的数据。</p>
<p>例子：<code>Person</code>对象转为JSON，或者 JSON转为<code>Person</code>，这将用到<code>MappingJackson2HttpMessageConverter</code></p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/20210205010509984.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter &#123;
	...
&#125;</code></pre>

<p>关于<code>MappingJackson2HttpMessageConverter</code>的实例化请看下节。</p>
<h3 id="关于HttpMessageConverters的初始化"><a href="#关于HttpMessageConverters的初始化" class="headerlink" title="关于HttpMessageConverters的初始化"></a>关于HttpMessageConverters的初始化</h3><p><code>DispatcherServlet</code>的初始化时会调用<code>initHandlerAdapters(ApplicationContext context)</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
    ...
    
	private void initHandlerAdapters(ApplicationContext context) &#123;
		this.handlerAdapters &#x3D; null;

		if (this.detectAllHandlerAdapters) &#123;
			&#x2F;&#x2F; Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
			Map&lt;String, HandlerAdapter&gt; matchingBeans &#x3D;
					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
			if (!matchingBeans.isEmpty()) &#123;
				this.handlerAdapters &#x3D; new ArrayList&lt;&gt;(matchingBeans.values());
				&#x2F;&#x2F; We keep HandlerAdapters in sorted order.
				AnnotationAwareOrderComparator.sort(this.handlerAdapters);
			&#125;
		&#125;
      ...</code></pre>

<p>上述代码会加载<code>ApplicationContext</code>的所有<code>HandlerAdapter</code>，用来处理<code>@RequestMapping</code>的<code>RequestMappingHandlerAdapter</code>实现<code>HandlerAdapter</code>接口，<code>RequestMappingHandlerAdapter</code>也被实例化。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
    
    ...

    private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;
    
    ...
    
	public RequestMappingHandlerAdapter() &#123;
		this.messageConverters &#x3D; new ArrayList&lt;&gt;(4);
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		if (!shouldIgnoreXml) &#123;
			try &#123;
				this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());
			&#125;
			catch (Error err) &#123;
				&#x2F;&#x2F; Ignore when no TransformerFactory implementation is available
			&#125;
		&#125;
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
	&#125;</code></pre>

<p>在构造器中看到<strong>一堆</strong><code>HttpMessageConverter</code>。接着，重点查看<code>AllEncompassingFormHttpMessageConverter</code>类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AllEncompassingFormHttpMessageConverter extends FormHttpMessageConverter &#123;

	&#x2F;**
	 * Boolean flag controlled by a &#123;@code spring.xml.ignore&#125; system property that instructs Spring to
	 * ignore XML, i.e. to not initialize the XML-related infrastructure.
	 * &lt;p&gt;The default is &quot;false&quot;.
	 *&#x2F;
	private static final boolean shouldIgnoreXml &#x3D; SpringProperties.getFlag(&quot;spring.xml.ignore&quot;);

	private static final boolean jaxb2Present;

	private static final boolean jackson2Present;

	private static final boolean jackson2XmlPresent;

	private static final boolean jackson2SmilePresent;

	private static final boolean gsonPresent;

	private static final boolean jsonbPresent;

	private static final boolean kotlinSerializationJsonPresent;

	static &#123;
		ClassLoader classLoader &#x3D; AllEncompassingFormHttpMessageConverter.class.getClassLoader();
		jaxb2Present &#x3D; ClassUtils.isPresent(&quot;javax.xml.bind.Binder&quot;, classLoader);
		jackson2Present &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp;
						ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader);
		jackson2XmlPresent &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);
		jackson2SmilePresent &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader);
		gsonPresent &#x3D; ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader);
		jsonbPresent &#x3D; ClassUtils.isPresent(&quot;javax.json.bind.Jsonb&quot;, classLoader);
		kotlinSerializationJsonPresent &#x3D; ClassUtils.isPresent(&quot;kotlinx.serialization.json.Json&quot;, classLoader);
	&#125;


	public AllEncompassingFormHttpMessageConverter() &#123;
		if (!shouldIgnoreXml) &#123;
			try &#123;
				addPartConverter(new SourceHttpMessageConverter&lt;&gt;());
			&#125;
			catch (Error err) &#123;
				&#x2F;&#x2F; Ignore when no TransformerFactory implementation is available
			&#125;

			if (jaxb2Present &amp;&amp; !jackson2XmlPresent) &#123;
				addPartConverter(new Jaxb2RootElementHttpMessageConverter());
			&#125;
		&#125;

		if (jackson2Present) &#123;
			addPartConverter(new MappingJackson2HttpMessageConverter());&#x2F;&#x2F;&lt;----重点看这里
		&#125;
		else if (gsonPresent) &#123;
			addPartConverter(new GsonHttpMessageConverter());
		&#125;
		else if (jsonbPresent) &#123;
			addPartConverter(new JsonbHttpMessageConverter());
		&#125;
		else if (kotlinSerializationJsonPresent) &#123;
			addPartConverter(new KotlinSerializationJsonHttpMessageConverter());
		&#125;

		if (jackson2XmlPresent &amp;&amp; !shouldIgnoreXml) &#123;
			addPartConverter(new MappingJackson2XmlHttpMessageConverter());
		&#125;

		if (jackson2SmilePresent) &#123;
			addPartConverter(new MappingJackson2SmileHttpMessageConverter());
		&#125;
	&#125;

&#125;

public class FormHttpMessageConverter implements HttpMessageConverter&lt;MultiValueMap&lt;String, ?&gt;&gt; &#123;
    
    ...
        
    private List&lt;HttpMessageConverter&lt;?&gt;&gt; partConverters &#x3D; new ArrayList&lt;&gt;();
    
    ...
        
    public void addPartConverter(HttpMessageConverter&lt;?&gt; partConverter) &#123;
		Assert.notNull(partConverter, &quot;&#39;partConverter&#39; must not be null&quot;);
		this.partConverters.add(partConverter);
	&#125;
    
    ...
&#125;
</code></pre>

<p>在<code>AllEncompassingFormHttpMessageConverter</code>类构造器看到<code>MappingJackson2HttpMessageConverter</code>类的实例化，<code>AllEncompassingFormHttpMessageConverter</code><strong>包含</strong><code>MappingJackson2HttpMessageConverter</code>。</p>
<p> <code>ReturnValueHandler</code>是怎么与<code>MappingJackson2HttpMessageConverter</code>关联起来？请看下节。</p>
<h3 id="ReturnValueHandler与MappingJackson2HttpMessageConverter关联"><a href="#ReturnValueHandler与MappingJackson2HttpMessageConverter关联" class="headerlink" title="ReturnValueHandler与MappingJackson2HttpMessageConverter关联"></a>ReturnValueHandler与MappingJackson2HttpMessageConverter关联</h3><p>再次回顾<code>RequestMappingHandlerAdapter</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
    
    ...
    @Nullable
	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;&#x2F;&#x2F;我们关注的returnValueHandlers
    
   	
    @Override
	@Nullable&#x2F;&#x2F;本方法在AbstractHandlerMethodAdapter
	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception &#123;

		return handleInternal(request, response, (HandlerMethod) handler);
	&#125;
        
    @Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;
		ModelAndView mav;
        ...
        mav &#x3D; invokeHandlerMethod(request, response, handlerMethod);
        ...
		return mav;
	&#125;
    
    @Nullable
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

		ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
		try &#123;
			WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);
			ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);

			ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
			if (this.argumentResolvers !&#x3D; null) &#123;
				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
			&#125;
			if (this.returnValueHandlers !&#x3D; null) &#123;&#x2F;&#x2F;&lt;---我们关注的returnValueHandlers
				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
			&#125;
            
            ...
            
			invocableMethod.invokeAndHandle(webRequest, mavContainer);
			if (asyncManager.isConcurrentHandlingStarted()) &#123;
				return null;
			&#125;

			return getModelAndView(mavContainer, modelFactory, webRequest);
		&#125;
		finally &#123;
			webRequest.requestCompleted();
		&#125;
	&#125;
    
   @Override
	public void afterPropertiesSet() &#123;
		&#x2F;&#x2F; Do this first, it may add ResponseBody advice beans
		
        ...
        
		if (this.returnValueHandlers &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;赋值returnValueHandlers
			List&lt;HandlerMethodReturnValueHandler&gt; handlers &#x3D; getDefaultReturnValueHandlers();
			this.returnValueHandlers &#x3D; new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
		&#125;
	&#125;
    
    private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123;
		List&lt;HandlerMethodReturnValueHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;(20);

		...
		&#x2F;&#x2F; Annotation-based return value types
        &#x2F;&#x2F;这里就是 ReturnValueHandler与 MappingJackson2HttpMessageConverter关联 的关键点
		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),&#x2F;&#x2F;&lt;---MessageConverters也就传参传进来的
				this.contentNegotiationManager, this.requestResponseBodyAdvice));&#x2F;&#x2F;
        ...

		return handlers;
	&#125;
    
    &#x2F;&#x2F;------
    
    public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;
		return this.messageConverters;
	&#125;
    
    &#x2F;&#x2F;RequestMappingHandlerAdapter构造器已初始化部分messageConverters
   	public RequestMappingHandlerAdapter() &#123;
		this.messageConverters &#x3D; new ArrayList&lt;&gt;(4);
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		if (!shouldIgnoreXml) &#123;
			try &#123;
				this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());
			&#125;
			catch (Error err) &#123;
				&#x2F;&#x2F; Ignore when no TransformerFactory implementation is available
			&#125;
		&#125;
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
	&#125;

    ...
              
&#125;</code></pre>

<p>应用中<code>WebMvcAutoConfiguration</code>（底层是<code>WebMvcConfigurationSupport</code>实现）传入更多<code>messageConverters</code>，其中就包含<code>MappingJackson2HttpMessageConverter</code>。</p>
<h2 id="39、响应处理-【源码分析】-内容协商原理"><a href="#39、响应处理-【源码分析】-内容协商原理" class="headerlink" title="39、响应处理-【源码分析】-内容协商原理"></a>39、响应处理-【源码分析】-内容协商原理</h2><p>根据客户端接收能力不同，返回不同媒体类型的数据。</p>
<p>引入XML依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> &lt;dependency&gt;
     &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;
     &lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>可用Postman软件分别测试返回json和xml：只需要改变请求头中Accept字段（application&#x2F;json、application&#x2F;xml）。</p>
<p>Http协议中规定的，Accept字段告诉服务器本客户端可以接收的数据类型。</p>
<p><strong>内容协商原理</strong>：</p>
<ol>
<li>判断当前响应头中是否已经有确定的媒体类型<code>MediaType</code>。</li>
<li>获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application&#x2F;xml）（这一步在下一节有详细介绍）<ul>
<li><code>contentNegotiationManager</code> 内容协商管理器 默认使用基于请求头的策略</li>
<li><code>HeaderContentNegotiationStrategy</code>  确定客户端可以接收的内容类型</li>
</ul>
</li>
<li>遍历循环所有当前系统的 <code>MessageConverter</code>，看谁支持操作这个对象（Person）</li>
<li>找到支持操作Person的converter，把converter支持的媒体类型统计出来。</li>
<li>客户端需要application&#x2F;xml，服务端有10种MediaType。</li>
<li>进行内容协商的最佳匹配媒体类型</li>
<li>用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;RequestResponseBodyMethodProcessor继承这类
public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver
		implements HandlerMethodReturnValueHandler &#123;

    ...
    
    &#x2F;&#x2F;跟上一节的代码一致
    protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,
                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;

            Object body;
            Class&lt;?&gt; valueType;
            Type targetType;

            if (value instanceof CharSequence) &#123;
                body &#x3D; value.toString();
                valueType &#x3D; String.class;
                targetType &#x3D; String.class;
            &#125;
            else &#123;
                body &#x3D; value;
                valueType &#x3D; getReturnValueType(body, returnType);
                targetType &#x3D; GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());
            &#125;

			...

            &#x2F;&#x2F;本节重点
            &#x2F;&#x2F;内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）
            MediaType selectedMediaType &#x3D; null;
            MediaType contentType &#x3D; outputMessage.getHeaders().getContentType();
            boolean isContentTypePreset &#x3D; contentType !&#x3D; null &amp;&amp; contentType.isConcrete();
            if (isContentTypePreset) &#123;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Found &#39;Content-Type:&quot; + contentType + &quot;&#39; in response&quot;);
                &#125;
                selectedMediaType &#x3D; contentType;
            &#125;
            else &#123;
                HttpServletRequest request &#x3D; inputMessage.getServletRequest();
                List&lt;MediaType&gt; acceptableTypes &#x3D; getAcceptableMediaTypes(request);
                &#x2F;&#x2F;服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据
                List&lt;MediaType&gt; producibleTypes &#x3D; getProducibleMediaTypes(request, valueType, targetType);

                if (body !&#x3D; null &amp;&amp; producibleTypes.isEmpty()) &#123;
                    throw new HttpMessageNotWritableException(
                            &quot;No converter found for return value of type: &quot; + valueType);
                &#125;
                List&lt;MediaType&gt; mediaTypesToUse &#x3D; new ArrayList&lt;&gt;();
                for (MediaType requestedType : acceptableTypes) &#123;
                    for (MediaType producibleType : producibleTypes) &#123;
                        if (requestedType.isCompatibleWith(producibleType)) &#123;
                            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));
                        &#125;
                    &#125;
                &#125;
                if (mediaTypesToUse.isEmpty()) &#123;
                    if (body !&#x3D; null) &#123;
                        throw new HttpMediaTypeNotAcceptableException(producibleTypes);
                    &#125;
                    if (logger.isDebugEnabled()) &#123;
                        logger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes);
                    &#125;
                    return;
                &#125;

                MediaType.sortBySpecificityAndQuality(mediaTypesToUse);

                &#x2F;&#x2F;选择一个MediaType
                for (MediaType mediaType : mediaTypesToUse) &#123;
                    if (mediaType.isConcrete()) &#123;
                        selectedMediaType &#x3D; mediaType;
                        break;
                    &#125;
                    else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;
                        selectedMediaType &#x3D; MediaType.APPLICATION_OCTET_STREAM;
                        break;
                    &#125;
                &#125;

                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Using &#39;&quot; + selectedMediaType + &quot;&#39;, given &quot; +
                            acceptableTypes + &quot; and supported &quot; + producibleTypes);
                &#125;
            &#125;

        	
            if (selectedMediaType !&#x3D; null) &#123;
                selectedMediaType &#x3D; selectedMediaType.removeQualityValue();
                &#x2F;&#x2F;本节主角：HttpMessageConverter
                for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123;
                    GenericHttpMessageConverter genericConverter &#x3D; (converter instanceof GenericHttpMessageConverter ?
                            (GenericHttpMessageConverter&lt;?&gt;) converter : null);
                    
                    &#x2F;&#x2F;判断是否可写
                    if (genericConverter !&#x3D; null ?
                            ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :
                            converter.canWrite(valueType, selectedMediaType)) &#123;
                        body &#x3D; getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
                                (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),
                                inputMessage, outputMessage);
                        if (body !&#x3D; null) &#123;
                            Object theBody &#x3D; body;
                            LogFormatUtils.traceDebug(logger, traceOn -&gt;
                                    &quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);
                            addContentDispositionHeader(inputMessage, outputMessage);
							&#x2F;&#x2F;开始写入
                            if (genericConverter !&#x3D; null) &#123;
                                genericConverter.write(body, targetType, selectedMediaType, outputMessage);
                            &#125;
                            else &#123;
                                ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);
                            &#125;
                        &#125;
                        else &#123;
                            if (logger.isDebugEnabled()) &#123;
                                logger.debug(&quot;Nothing to write: null body&quot;);
                            &#125;
                        &#125;
                        return;
                    &#125;
                &#125;
            &#125;
			...
        &#125;</code></pre>



<h2 id="40、响应处理-【源码分析】-基于请求参数的内容协商原理"><a href="#40、响应处理-【源码分析】-基于请求参数的内容协商原理" class="headerlink" title="40、响应处理-【源码分析】-基于请求参数的内容协商原理"></a>40、响应处理-【源码分析】-基于请求参数的内容协商原理</h2><p>上一节内容协商原理的第二步：</p>
<p>获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application&#x2F;xml）</p>
<ul>
<li><code>contentNegotiationManager</code> 内容协商管理器 默认使用基于请求头的策略</li>
<li><code>HeaderContentNegotiationStrategy</code>  确定客户端可以接收的内容类型</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;RequestResponseBodyMethodProcessor继承这类
public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver
		implements HandlerMethodReturnValueHandler &#123;

    ...
    
    &#x2F;&#x2F;跟上一节的代码一致
    protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,
                ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
                throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;

            Object body;
            Class&lt;?&gt; valueType;
            Type targetType;
        
        	...
        
                    &#x2F;&#x2F;本节重点
            &#x2F;&#x2F;内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）
            MediaType selectedMediaType &#x3D; null;
            MediaType contentType &#x3D; outputMessage.getHeaders().getContentType();
            boolean isContentTypePreset &#x3D; contentType !&#x3D; null &amp;&amp; contentType.isConcrete();
            if (isContentTypePreset) &#123;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Found &#39;Content-Type:&quot; + contentType + &quot;&#39; in response&quot;);
                &#125;
                selectedMediaType &#x3D; contentType;
            &#125;
            else &#123;
                HttpServletRequest request &#x3D; inputMessage.getServletRequest();
                List&lt;MediaType&gt; acceptableTypes &#x3D; getAcceptableMediaTypes(request);
                &#x2F;&#x2F;服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据
                List&lt;MediaType&gt; producibleTypes &#x3D; getProducibleMediaTypes(request, valueType, targetType);
            ...
            
	&#125;
    
    &#x2F;&#x2F;在AbstractMessageConverterMethodArgumentResolver类内
   	private List&lt;MediaType&gt; getAcceptableMediaTypes(HttpServletRequest request)
			throws HttpMediaTypeNotAcceptableException &#123;

        &#x2F;&#x2F;内容协商管理器 默认使用基于请求头的策略
		return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));
	&#125;
        
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver &#123;
	
    ...
    
    public ContentNegotiationManager() &#123;
		this(new HeaderContentNegotiationStrategy());&#x2F;&#x2F;内容协商管理器 默认使用基于请求头的策略
	&#125;
    
    @Override
	public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123;
		for (ContentNegotiationStrategy strategy : this.strategies) &#123;
			List&lt;MediaType&gt; mediaTypes &#x3D; strategy.resolveMediaTypes(request);
			if (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) &#123;
				continue;
			&#125;
			return mediaTypes;
		&#125;
		return MEDIA_TYPE_ALL_LIST;
	&#125;
    ...
    
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;基于请求头的策略
public class HeaderContentNegotiationStrategy implements ContentNegotiationStrategy &#123;

	&#x2F;**
	 * &#123;@inheritDoc&#125;
	 * @throws HttpMediaTypeNotAcceptableException if the &#39;Accept&#39; header cannot be parsed
	 *&#x2F;
	@Override
	public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request)
			throws HttpMediaTypeNotAcceptableException &#123;

		String[] headerValueArray &#x3D; request.getHeaderValues(HttpHeaders.ACCEPT);
		if (headerValueArray &#x3D;&#x3D; null) &#123;
			return MEDIA_TYPE_ALL_LIST;
		&#125;

		List&lt;String&gt; headerValues &#x3D; Arrays.asList(headerValueArray);
		try &#123;
			List&lt;MediaType&gt; mediaTypes &#x3D; MediaType.parseMediaTypes(headerValues);
			MediaType.sortBySpecificityAndQuality(mediaTypes);
			return !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;
		&#125;
		catch (InvalidMediaTypeException ex) &#123;
			throw new HttpMediaTypeNotAcceptableException(
					&quot;Could not parse &#39;Accept&#39; header &quot; + headerValues + &quot;: &quot; + ex.getMessage());
		&#125;
	&#125;

&#125;</code></pre>



<h3 id="开启浏览器参数方式内容协商功能"><a href="#开启浏览器参数方式内容协商功能" class="headerlink" title="开启浏览器参数方式内容协商功能"></a>开启浏览器参数方式内容协商功能</h3><p>为了方便内容协商，开启基于请求参数的内容协商功能。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  mvc:
    contentnegotiation:
      favor-parameter: true  #开启请求参数内容协商模式</code></pre>

<p>内容协商管理器，就会多了一个<code>ParameterContentNegotiationStrategy</code>（由Spring容器注入）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ParameterContentNegotiationStrategy extends AbstractMappingContentNegotiationStrategy &#123;

	private String parameterName &#x3D; &quot;format&quot;;&#x2F;&#x2F;


	&#x2F;**
	 * Create an instance with the given map of file extensions and media types.
	 *&#x2F;
	public ParameterContentNegotiationStrategy(Map&lt;String, MediaType&gt; mediaTypes) &#123;
		super(mediaTypes);
	&#125;


	&#x2F;**
	 * Set the name of the parameter to use to determine requested media types.
	 * &lt;p&gt;By default this is set to &#123;@code &quot;format&quot;&#125;.
	 *&#x2F;
	public void setParameterName(String parameterName) &#123;
		Assert.notNull(parameterName, &quot;&#39;parameterName&#39; is required&quot;);
		this.parameterName &#x3D; parameterName;
	&#125;

	public String getParameterName() &#123;
		return this.parameterName;
	&#125;


	@Override
	@Nullable
	protected String getMediaTypeKey(NativeWebRequest request) &#123;
		return request.getParameter(getParameterName());
	&#125;
    
    &#x2F;&#x2F;---以下方法在AbstractMappingContentNegotiationStrategy类
    
    @Override
	public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest webRequest)
			throws HttpMediaTypeNotAcceptableException &#123;

		return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest));
	&#125;

	&#x2F;**
	 * An alternative to &#123;@link #resolveMediaTypes(NativeWebRequest)&#125; that accepts
	 * an already extracted key.
	 * @since 3.2.16
	 *&#x2F;
	public List&lt;MediaType&gt; resolveMediaTypeKey(NativeWebRequest webRequest, @Nullable String key)
			throws HttpMediaTypeNotAcceptableException &#123;

		if (StringUtils.hasText(key)) &#123;
			MediaType mediaType &#x3D; lookupMediaType(key);
			if (mediaType !&#x3D; null) &#123;
				handleMatch(key, mediaType);
				return Collections.singletonList(mediaType);
			&#125;
			mediaType &#x3D; handleNoMatch(webRequest, key);
			if (mediaType !&#x3D; null) &#123;
				addMapping(key, mediaType);
				return Collections.singletonList(mediaType);
			&#125;
		&#125;
		return MEDIA_TYPE_ALL_LIST;
	&#125;
    

&#125;</code></pre>

<p>然后，浏览器地址输入带format参数的URL：</p>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;person?format&#x3D;json
或
http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;person?format&#x3D;xml</code></pre>

<p>这样，后端会根据参数format的值，返回对应json或xml格式的数据。</p>
<h2 id="41、响应处理-【源码分析】-自定义MessageConverter"><a href="#41、响应处理-【源码分析】-自定义MessageConverter" class="headerlink" title="41、响应处理-【源码分析】-自定义MessageConverter"></a>41、响应处理-【源码分析】-自定义MessageConverter</h2><p><strong>实现多协议数据兼容。json、xml、x-guigu</strong>（这个是自创的）</p>
<ol>
<li><p><code>@ResponseBody</code> 响应数据出去 调用 <code>RequestResponseBodyMethodProcessor</code> 处理</p>
</li>
<li><p>Processor 处理方法返回值。通过 <code>MessageConverter</code>处理</p>
</li>
<li><p>所有 <code>MessageConverter</code> 合起来可以支持各种媒体类型数据的操作（读、写）</p>
</li>
<li><p>内容协商找到最终的 <code>messageConverter</code></p>
</li>
</ol>
<p>SpringMVC的什么功能，一个入口给容器中添加一个  <code>WebMvcConfigurer</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
public class WebConfig &#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;

            @Override
            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
                converters.add(new GuiguMessageConverter());
            &#125;
        &#125;
    &#125;
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 自定义的Converter
 *&#x2F;
public class GuiguMessageConverter implements HttpMessageConverter&lt;Person&gt; &#123;

    @Override
    public boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType) &#123;
        return false;
    &#125;

    @Override
    public boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) &#123;
        return clazz.isAssignableFrom(Person.class);
    &#125;

    &#x2F;**
     * 服务器要统计所有MessageConverter都能写出哪些内容类型
     *
     * application&#x2F;x-guigu
     * @return
     *&#x2F;
    @Override
    public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;
        return MediaType.parseMediaTypes(&quot;application&#x2F;x-guigu&quot;);
    &#125;

    @Override
    public Person read(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;
        return null;
    &#125;

    @Override
    public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;
        &#x2F;&#x2F;自定义协议数据的写出
        String data &#x3D; person.getUserName()+&quot;;&quot;+person.getAge()+&quot;;&quot;+person.getBirth();


        &#x2F;&#x2F;写出去
        OutputStream body &#x3D; outputMessage.getBody();
        body.write(data.getBytes());
    &#125;
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Date;

@Controller
public class ResponseTestController &#123;

    &#x2F;**
     * 1、浏览器发请求直接返回 xml    [application&#x2F;xml]        jacksonXmlConverter
     * 2、如果是ajax请求 返回 json   [application&#x2F;json]      jacksonJsonConverter
     * 3、如果硅谷app发请求，返回自定义协议数据  [appliaction&#x2F;x-guigu]   xxxxConverter
     *          属性值1;属性值2;
     *
     * 步骤：
     * 1、添加自定义的MessageConverter进系统底层
     * 2、系统底层就会统计出所有MessageConverter能操作哪些类型
     * 3、客户端内容协商 [guigu---&gt;guigu]
     *
     * 作业：如何以参数的方式进行内容协商
     * @return
     *&#x2F;
    @ResponseBody  &#x2F;&#x2F;利用返回值处理器里面的消息转换器进行处理
    @GetMapping(value &#x3D; &quot;&#x2F;test&#x2F;person&quot;)
    public Person getPerson()&#123;
        Person person &#x3D; new Person();
        person.setAge(28);
        person.setBirth(new Date());
        person.setUserName(&quot;zhangsan&quot;);
        return person;
    &#125;

&#125;</code></pre>



<p>用Postman发送<code>/test/person</code>（请求头<code>Accept:application/x-guigu</code>)，将返回自定义协议数据的写出。</p>
<h2 id="42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配"><a href="#42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配" class="headerlink" title="42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配"></a>42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配</h2><p>假设你想基于自定义请求参数的自定义内容协商功能。</p>
<p>换句话，在地址栏输入<code>http://localhost:8080/test/person?format=gg</code>返回数据，跟<code>http://localhost:8080/test/person</code>且请求头参数<code>Accept:application/x-guigu</code>的返回自定义协议数据的一致。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
public class WebConfig &#x2F;*implements WebMvcConfigurer*&#x2F; &#123;

    &#x2F;&#x2F;1、WebMvcConfigurer定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;

            &#x2F;**
             * 自定义内容协商策略
             * @param configurer
             *&#x2F;
            @Override
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;
                &#x2F;&#x2F;Map&lt;String, MediaType&gt; mediaTypes
                Map&lt;String, MediaType&gt; mediaTypes &#x3D; new HashMap&lt;&gt;();
                mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);
                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);
                &#x2F;&#x2F;自定义媒体类型
                mediaTypes.put(&quot;gg&quot;,MediaType.parseMediaType(&quot;application&#x2F;x-guigu&quot;));
                &#x2F;&#x2F;指定支持解析哪些参数对应的哪些媒体类型
                ParameterContentNegotiationStrategy parameterStrategy &#x3D; new ParameterContentNegotiationStrategy(mediaTypes);
&#x2F;&#x2F;                parameterStrategy.setParameterName(&quot;ff&quot;);

                &#x2F;&#x2F;还需添加请求头处理策略，否则accept:application&#x2F;json、application&#x2F;xml则会失效
                HeaderContentNegotiationStrategy headeStrategy &#x3D; new HeaderContentNegotiationStrategy();

                configurer.strategies(Arrays.asList(parameterStrategy, headeStrategy));
            &#125;
        &#125;
    &#125;
    
    ...
    
&#125;</code></pre>

<p>日后开发要注意，<strong>有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。</strong></p>
<h2 id="43、视图解析-Thymeleaf初体验"><a href="#43、视图解析-Thymeleaf初体验" class="headerlink" title="43、视图解析-Thymeleaf初体验"></a>43、视图解析-Thymeleaf初体验</h2><blockquote>
<p><strong>Thymeleaf</strong> is a modern server-side Java template engine for both web and standalone environments.</p>
<p>Thymeleaf’s main goal is to bring elegant <em>natural templates</em> to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams.</p>
<p>With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.——<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">Link</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/documentation.html">Thymeleaf官方文档</a></p>
<h3 id="thymeleaf使用"><a href="#thymeleaf使用" class="headerlink" title="thymeleaf使用"></a>thymeleaf使用</h3><h4 id="引入Starter"><a href="#引入Starter" class="headerlink" title="引入Starter"></a>引入Starter</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<h4 id="自动配置好了thymeleaf"><a href="#自动配置好了thymeleaf" class="headerlink" title="自动配置好了thymeleaf"></a>自动配置好了thymeleaf</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)
@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)
public class ThymeleafAutoConfiguration &#123;
    ...
&#125;</code></pre>

<p>自动配好的策略</p>
<ol>
<li><p>所有thymeleaf的配置值都在 ThymeleafProperties</p>
</li>
<li><p>配置好了 <strong>SpringTemplateEngine</strong> </p>
</li>
<li><p>配好了 <strong>ThymeleafViewResolver</strong> </p>
</li>
<li><p>我们只需要直接开发页面</p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;&#x2F;&#x2F;模板放置处
public static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;&#x2F;&#x2F;文件的后缀名</code></pre>

<p>编写一个控制层：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class ViewTestController &#123;
    @GetMapping(&quot;&#x2F;hello&quot;)
    public String hello(Model model)&#123;
        &#x2F;&#x2F;model中的数据会被放在请求域中 request.setAttribute(&quot;a&quot;,aa)
        model.addAttribute(&quot;msg&quot;,&quot;一定要大力发展工业文化&quot;);
        model.addAttribute(&quot;link&quot;,&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);
        return &quot;success&quot;;
    &#125;
&#125;</code></pre>

<p><code>/templates/success.html</code>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
&lt;h1 th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;nice&lt;&#x2F;h1&gt;
&lt;h2&gt;
    &lt;a href&#x3D;&quot;www.baidu.com&quot; th:href&#x3D;&quot;$&#123;link&#125;&quot;&gt;去百度&lt;&#x2F;a&gt;  &lt;br&#x2F;&gt;
    &lt;a href&#x3D;&quot;www.google.com&quot; th:href&#x3D;&quot;@&#123;&#x2F;link&#125;&quot;&gt;去百度&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>

<hr>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:
  servlet:
    context-path: &#x2F;app #设置应用名</code></pre>

<p>这个设置后，URL要插入<code>/app</code>,  如<code>http://localhost:8080/app/hello.html</code>。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><table>
<thead>
<tr>
<th>表达式名字</th>
<th>语法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td>变量取值</td>
<td>${…}</td>
<td align="center">获取请求域、session域、对象等值</td>
</tr>
<tr>
<td>选择变量</td>
<td>*{…}</td>
<td align="center">获取上下文对象值</td>
</tr>
<tr>
<td>消息</td>
<td>#{…}</td>
<td align="center">获取国际化等值</td>
</tr>
<tr>
<td>链接</td>
<td>@{…}</td>
<td align="center">生成链接</td>
</tr>
<tr>
<td>片段表达式</td>
<td>~{…}</td>
<td align="center">jsp:include 作用，引入公共页面片段</td>
</tr>
</tbody></table>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ul>
<li>文本值: <strong>‘one text’</strong> <strong>,</strong> <strong>‘Another one!’</strong> <strong>,…</strong></li>
<li>数字: <strong>0</strong> <strong>,</strong> <strong>34</strong> <strong>,</strong> <strong>3.0</strong> <strong>,</strong> <strong>12.3</strong> <strong>,…</strong></li>
<li>布尔值: <strong>true</strong> <strong>,</strong> <strong>false</strong></li>
<li>空值: <strong>null</strong></li>
<li>变量： one，two，…. 变量不能有空格</li>
</ul>
<h4 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h4><ul>
<li>字符串拼接: <strong>+</strong></li>
<li>变量替换: <strong>|The name is ${name}|</strong></li>
</ul>
<h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><ul>
<li>运算符: + , - , * , &#x2F; , %</li>
</ul>
<h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><ul>
<li>运算符:  <strong>and</strong> <strong>,</strong> <strong>or</strong></li>
<li>一元运算: <strong>!</strong> <strong>,</strong> <strong>not</strong></li>
</ul>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><ul>
<li>比较: <strong>&gt;</strong> <strong>,</strong> <strong>&lt;** **,** **&gt;&#x3D;</strong> <strong>,</strong> <strong>&lt;&#x3D;</strong> <strong>(</strong> <strong>gt</strong> <strong>,</strong> <strong>lt</strong> <strong>,</strong> <strong>ge</strong> <strong>,</strong> <strong>le</strong> <strong>)</strong></li>
<li>等式: <strong>&#x3D;&#x3D;</strong> <strong>,</strong> <strong>!&#x3D;</strong> <strong>(</strong> <strong>eq</strong> <strong>,</strong> <strong>ne</strong> <strong>)</strong></li>
</ul>
<h4 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h4><ul>
<li>If-then: <strong>(if) ? (then)</strong></li>
<li>If-then-else: <strong>(if) ? (then) : (else)</strong></li>
<li>Default: (value) <strong>?: (defaultvalue)</strong></li>
</ul>
<h4 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h4><ul>
<li>无操作： _</li>
</ul>
<h3 id="设置属性值-th-attr"><a href="#设置属性值-th-attr" class="headerlink" title="设置属性值-th:attr"></a>设置属性值-th:attr</h3><ul>
<li>设置单个值</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;subscribe.html&quot; th:attr&#x3D;&quot;action&#x3D;@&#123;&#x2F;subscribe&#125;&quot;&gt;
  &lt;fieldset&gt;
    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; &#x2F;&gt;
    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Subscribe!&quot; th:attr&#x3D;&quot;value&#x3D;#&#123;subscribe.submit&#125;&quot;&#x2F;&gt;
  &lt;&#x2F;fieldset&gt;
&lt;&#x2F;form&gt;</code></pre>

<ul>
<li>设置多个值</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;images&#x2F;gtvglogo.png&quot;  
     th:attr&#x3D;&quot;src&#x3D;@&#123;&#x2F;images&#x2F;gtvglogo.png&#125;,title&#x3D;#&#123;logo&#125;,alt&#x3D;#&#123;logo&#125;&quot; &#x2F;&gt;</code></pre>

<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-attribute-values">官方文档 - 5 Setting Attribute Values</a></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;tr th:each&#x3D;&quot;prod : $&#123;prods&#125;&quot;&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;&#x2F;td&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;&#x2F;td&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;&#x2F;td&gt;
&lt;&#x2F;tr&gt;</code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;tr th:each&#x3D;&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class&#x3D;&quot;$&#123;iterStat.odd&#125;? &#39;odd&#39;&quot;&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;&#x2F;td&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;&#x2F;td&gt;
    &lt;td th:text&#x3D;&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;&#x2F;td&gt;
&lt;&#x2F;tr&gt;</code></pre>

<h3 id="条件运算-1"><a href="#条件运算-1" class="headerlink" title="条件运算"></a>条件运算</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a href&#x3D;&quot;comments.html&quot;
	th:href&#x3D;&quot;@&#123;&#x2F;product&#x2F;comments(prodId&#x3D;$&#123;prod.id&#125;)&#125;&quot;
	th:if&#x3D;&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;&#x2F;a&gt;</code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;
      &lt;p th:case&#x3D;&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;&#x2F;p&gt;
      &lt;p th:case&#x3D;&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;&#x2F;p&gt;
      &lt;p th:case&#x3D;&quot;*&quot;&gt;User is some other thing&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;</code></pre>

<h3 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h3><table>
<thead>
<tr>
<th align="left">Order</th>
<th align="left">Feature</th>
<th align="left">Attributes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Fragment inclusion</td>
<td align="left"><code>th:insert</code> <code>th:replace</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Fragment iteration</td>
<td align="left"><code>th:each</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Conditional evaluation</td>
<td align="left"><code>th:if</code> <code>th:unless</code> <code>th:switch</code> <code>th:case</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Local variable definition</td>
<td align="left"><code>th:object</code> <code>th:with</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">General attribute modification</td>
<td align="left"><code>th:attr</code> <code>th:attrprepend</code> <code>th:attrappend</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Specific attribute modification</td>
<td align="left"><code>th:value</code> <code>th:href</code> <code>th:src</code> <code>...</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Text (tag body modification)</td>
<td align="left"><code>th:text</code> <code>th:utext</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Fragment specification</td>
<td align="left"><code>th:fragment</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Fragment removal</td>
<td align="left"><code>th:remove</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence">官方文档 - 10 Attribute Precedence</a></p>
<h2 id="44、web实验-后台管理系统基本功能"><a href="#44、web实验-后台管理系统基本功能" class="headerlink" title="44、web实验-后台管理系统基本功能"></a>44、web实验-后台管理系统基本功能</h2><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><p>使用IDEA的Spring Initializr。</p>
<ul>
<li>thymeleaf、</li>
<li>web-starter、</li>
<li>devtools、</li>
<li>lombok</li>
</ul>
<h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3><ul>
<li><p><code>/static</code> 放置 css，js等静态资源</p>
</li>
<li><p><code>/templates/login.html</code> 登录页</p>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;!-- 要加这玩意thymeleaf才能用 --&gt;

&lt;form class&#x3D;&quot;form-signin&quot; action&#x3D;&quot;index.html&quot; method&#x3D;&quot;post&quot; th:action&#x3D;&quot;@&#123;&#x2F;login&#125;&quot;&gt;

    ...
    
    &lt;!-- 消息提醒 --&gt;
    &lt;label style&#x3D;&quot;color: red&quot; th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;&lt;&#x2F;label&gt;
    
    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;userName&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;User ID&quot; autofocus&gt;
    &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Password&quot;&gt;
    
    &lt;button class&#x3D;&quot;btn btn-lg btn-login btn-block&quot; type&#x3D;&quot;submit&quot;&gt;
        &lt;i class&#x3D;&quot;fa fa-check&quot;&gt;&lt;&#x2F;i&gt;
    &lt;&#x2F;button&gt;
    
    ...
    
&lt;&#x2F;form&gt;</code></pre>

<ul>
<li><code>/templates/main.html</code> 主页</li>
</ul>
<p>thymeleaf内联写法：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;&#x2F;p&gt;</code></pre>

<h3 id="登录控制层"><a href="#登录控制层" class="headerlink" title="登录控制层"></a>登录控制层</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class IndexController &#123;
    &#x2F;**
     * 来登录页
     * @return
     *&#x2F;
    @GetMapping(value &#x3D; &#123;&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;&#125;)
    public String loginPage()&#123;

        return &quot;login&quot;;
    &#125;

    @PostMapping(&quot;&#x2F;login&quot;)
    public String main(User user, HttpSession session, Model model)&#123; &#x2F;&#x2F;RedirectAttributes

        if(StringUtils.hasLength(user.getUserName()) &amp;&amp; &quot;123456&quot;.equals(user.getPassword()))&#123;
            &#x2F;&#x2F;把登陆成功的用户保存起来
            session.setAttribute(&quot;loginUser&quot;,user);
            &#x2F;&#x2F;登录成功重定向到main.html;  重定向防止表单重复提交
            return &quot;redirect:&#x2F;main.html&quot;;
        &#125;else &#123;
            model.addAttribute(&quot;msg&quot;,&quot;账号密码错误&quot;);
            &#x2F;&#x2F;回到登录页面
            return &quot;login&quot;;
        &#125;
    &#125;
    
     &#x2F;**
     * 去main页面
     * @return
     *&#x2F;
    @GetMapping(&quot;&#x2F;main.html&quot;)
    public String mainPage(HttpSession session, Model model)&#123;
        
        &#x2F;&#x2F;最好用拦截器,过滤器
        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);
        if(loginUser !&#x3D; null)&#123;
        	return &quot;main&quot;;
        &#125;else &#123;
            &#x2F;&#x2F;session过期，没有登陆过
        	&#x2F;&#x2F;回到登录页面
	        model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;);
    	    return &quot;login&quot;;
        &#125;
    &#125;
    
&#125;</code></pre>



<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AllArgsConstructor
@NoArgsConstructor
@Data
public class User &#123;
    private String userName;
    private String password;
&#125;</code></pre>



<h2 id="45、web实验-抽取公共页面"><a href="#45、web实验-抽取公共页面" class="headerlink" title="45、web实验-抽取公共页面"></a>45、web实验-抽取公共页面</h2><p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#template-layout">官方文档 - Template Layout</a></p>
<ul>
<li>公共页面<code>/templates/common.html</code></li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;!--注意要添加xmlns:th才能添加thymeleaf的标签--&gt;
&lt;head th:fragment&#x3D;&quot;commonheader&quot;&gt;
    &lt;!--common--&gt;
    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;style.css&#125;&quot; rel&#x3D;&quot;stylesheet&quot;&gt;
    &lt;link href&#x3D;&quot;css&#x2F;style-responsive.css&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;style-responsive.css&#125;&quot; rel&#x3D;&quot;stylesheet&quot;&gt;
    ...
&lt;&#x2F;head&gt;
&lt;body&gt;
&lt;!-- left side start--&gt;
&lt;div id&#x3D;&quot;leftmenu&quot; class&#x3D;&quot;left-side sticky-left-side&quot;&gt;
	...

    &lt;div class&#x3D;&quot;left-side-inner&quot;&gt;
		...

        &lt;!--sidebar nav start--&gt;
        &lt;ul class&#x3D;&quot;nav nav-pills nav-stacked custom-nav&quot;&gt;
            &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;main.html&#125;&quot;&gt;&lt;i class&#x3D;&quot;fa fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;span&gt;Dashboard&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
            ...
            &lt;li class&#x3D;&quot;menu-list nav-active&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;&lt;i class&#x3D;&quot;fa fa-th-list&quot;&gt;&lt;&#x2F;i&gt; &lt;span&gt;Data Tables&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
                &lt;ul class&#x3D;&quot;sub-menu-list&quot;&gt;
                    &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;basic_table&#125;&quot;&gt; Basic Table&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
                    &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;dynamic_table&#125;&quot;&gt; Advanced Table&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
                    &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;responsive_table&#125;&quot;&gt; Responsive Table&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
                    &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;editable_table&#125;&quot;&gt; Edit Table&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
                &lt;&#x2F;ul&gt;
            &lt;&#x2F;li&gt;
            ...
        &lt;&#x2F;ul&gt;
        &lt;!--sidebar nav end--&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;!-- left side end--&gt;


&lt;!-- header section start--&gt;
&lt;div th:fragment&#x3D;&quot;headermenu&quot; class&#x3D;&quot;header-section&quot;&gt;

    &lt;!--toggle button start--&gt;
    &lt;a class&#x3D;&quot;toggle-btn&quot;&gt;&lt;i class&#x3D;&quot;fa fa-bars&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;a&gt;
    &lt;!--toggle button end--&gt;
	...

&lt;&#x2F;div&gt;
&lt;!-- header section end--&gt;

&lt;div id&#x3D;&quot;commonscript&quot;&gt;
    &lt;!-- Placed js at the end of the document so the pages load faster --&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery-1.10.2.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery-ui-1.9.2.custom.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery-migrate-1.2.1.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;bootstrap.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;modernizr.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery.nicescroll.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
    &lt;!--common scripts for all pages--&gt;
    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;scripts.js&#125;&quot;&gt;&lt;&#x2F;script&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>



<ul>
<li><code>/templates/table/basic_table.html</code></li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;
  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0&quot;&gt;
  &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot;&gt;
  &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;ThemeBucket&quot;&gt;
  &lt;link rel&#x3D;&quot;shortcut icon&quot; href&#x3D;&quot;#&quot; type&#x3D;&quot;image&#x2F;png&quot;&gt;

  &lt;title&gt;Basic Table&lt;&#x2F;title&gt;
    &lt;div th:include&#x3D;&quot;common :: commonheader&quot;&gt; &lt;&#x2F;div&gt;&lt;!--将common.html的代码段 插进来--&gt;
&lt;&#x2F;head&gt;

&lt;body class&#x3D;&quot;sticky-header&quot;&gt;

&lt;section&gt;
&lt;div th:replace&#x3D;&quot;common :: #leftmenu&quot;&gt;&lt;&#x2F;div&gt;
    
    &lt;!-- main content start--&gt;
    &lt;div class&#x3D;&quot;main-content&quot; &gt;

        &lt;div th:replace&#x3D;&quot;common :: headermenu&quot;&gt;&lt;&#x2F;div&gt;
        ...
    &lt;&#x2F;div&gt;
    &lt;!-- main content end--&gt;
&lt;&#x2F;section&gt;

&lt;!-- Placed js at the end of the document so the pages load faster --&gt;
&lt;div th:replace&#x3D;&quot;common :: #commonscript&quot;&gt;&lt;&#x2F;div&gt;


&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;
</code></pre>

<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#difference-between-thinsert-and-threplace-and-thinclude">Difference between <code>th:insert</code> and <code>th:replace</code> (and <code>th:include</code>)</a></p>
<h2 id="46、web实验-遍历数据与页面bug修改"><a href="#46、web实验-遍历数据与页面bug修改" class="headerlink" title="46、web实验-遍历数据与页面bug修改"></a>46、web实验-遍历数据与页面bug修改</h2><p>控制层代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;dynamic_table&quot;)
public String dynamic_table(Model model)&#123;
    &#x2F;&#x2F;表格内容的遍历
    List&lt;User&gt; users &#x3D; Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),
                                     new User(&quot;lisi&quot;, &quot;123444&quot;),
                                     new User(&quot;haha&quot;, &quot;aaaaa&quot;),
                                     new User(&quot;hehe &quot;, &quot;aaddd&quot;));
    model.addAttribute(&quot;users&quot;,users);

    return &quot;table&#x2F;dynamic_table&quot;;
&#125;</code></pre>

<p>页面代码：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table class&#x3D;&quot;display table table-bordered&quot; id&#x3D;&quot;hidden-table-info&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;#&lt;&#x2F;th&gt;
            &lt;th&gt;用户名&lt;&#x2F;th&gt;
            &lt;th&gt;密码&lt;&#x2F;th&gt;
        &lt;&#x2F;tr&gt;
    &lt;&#x2F;thead&gt;
    &lt;tbody&gt;
        &lt;tr class&#x3D;&quot;gradeX&quot; th:each&#x3D;&quot;user,stats:$&#123;users&#125;&quot;&gt;
            &lt;td th:text&#x3D;&quot;$&#123;stats.count&#125;&quot;&gt;Trident&lt;&#x2F;td&gt;
            &lt;td th:text&#x3D;&quot;$&#123;user.userName&#125;&quot;&gt;Internet&lt;&#x2F;td&gt;
            &lt;td &gt;[[$&#123;user.password&#125;]]&lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
    &lt;&#x2F;tbody&gt;
&lt;&#x2F;table&gt;</code></pre>



<h2 id="47、视图解析-【源码分析】-视图解析器与视图"><a href="#47、视图解析-【源码分析】-视图解析器与视图" class="headerlink" title="47、视图解析-【源码分析】-视图解析器与视图"></a>47、视图解析-【源码分析】-视图解析器与视图</h2><p><strong>视图解析原理流程</strong>：</p>
<ol>
<li><p>目标方法处理的过程中（阅读<code>DispatcherServlet</code>源码），所有数据都会被放在 <code>ModelAndViewContainer</code> 里面，其中包括数据和视图地址。</p>
</li>
<li><p>方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 <code>ModelAndViewContainer</code> 。</p>
</li>
<li><p>任何目标方法执行完成以后都会返回<code>ModelAndView</code>（数据和视图地址）。</p>
</li>
<li><p><code>processDispatchResult()</code>处理派发结果（页面改如何响应）</p>
<ul>
<li><p><code>render(mv, request, response);</code> 进行页面渲染逻辑</p>
<ul>
<li>根据方法的<code>String</code>返回值得到 <code>View</code> 对象【定义了页面的渲染逻辑】</li>
</ul>
<ol>
<li>所有的视图解析器尝试是否能根据当前返回值得到<code>View</code>对象</li>
<li>得到了  <code>redirect:/main.html --&gt; Thymeleaf new RedirectView()</code>。</li>
<li><code>ContentNegotiationViewResolver</code> 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。</li>
<li><code>view.render(mv.getModelInternal(), request, response);</code>  视图对象调用自定义的render进行页面渲染工作。</li>
</ol>
<ul>
<li><code>RedirectView</code> 如何渲染【重定向到一个页面】</li>
<li>获取目标url地址	</li>
<li><code>response.sendRedirect(encodedURL);</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>视图解析</strong>：<br>    - 返回值以 <code>forward:</code> 开始： <code>new InternalResourceView(forwardUrl);</code> –&gt;  转发<code>request.getRequestDispatcher(path).forward(request, response);</code><br>    - 返回值以 <code>redirect:</code> 开始： <code>new RedirectView()</code> –&gt; render就是重定向<br>    - 返回值是普通字符串：<code>new ThymeleafView()</code>—&gt;</p>
<hr>
<p>阅读源码：最好自己在IDE，打断点，且Debug模式运行实例，这样比较没那么沉闷。</p>
<h2 id="48、拦截器-登录检查与静态资源放行"><a href="#48、拦截器-登录检查与静态资源放行" class="headerlink" title="48、拦截器-登录检查与静态资源放行"></a>48、拦截器-登录检查与静态资源放行</h2><ol>
<li><p>编写一个拦截器实现<code>HandlerInterceptor</code>接口</p>
</li>
<li><p>拦截器注册到容器中（实现<code>WebMvcConfigurer</code>的<code>addInterceptors()</code>）</p>
</li>
<li><p>指定拦截规则（<span style="color:red;">注意</span>，如果是拦截所有，静态资源也会被拦截】</p>
</li>
</ol>
<p>编写一个实现<code>HandlerInterceptor</code>接口的拦截器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
public class LoginInterceptor implements HandlerInterceptor &#123;

    &#x2F;**
     * 目标方法执行之前
     *&#x2F;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String requestURI &#x3D; request.getRequestURI();
        log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI);

        &#x2F;&#x2F;登录检查逻辑
        HttpSession session &#x3D; request.getSession();

        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);

        if(loginUser !&#x3D; null)&#123;
            &#x2F;&#x2F;放行
            return true;
        &#125;

        &#x2F;&#x2F;拦截住。未登录。跳转到登录页
        request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);
&#x2F;&#x2F;        re.sendRedirect(&quot;&#x2F;&quot;);
        request.getRequestDispatcher(&quot;&#x2F;&quot;).forward(request,response);
        return false;
    &#125;

    &#x2F;**
     * 目标方法执行完成以后
     *&#x2F;
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);
    &#125;

    &#x2F;**
     * 页面渲染以后
     *&#x2F;
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex);
    &#125;
&#125;</code></pre>



<p>拦截器注册到容器中 &amp;&amp; 指定拦截规则：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class AdminWebConfig implements WebMvcConfigurer&#123;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new LoginInterceptor())&#x2F;&#x2F;拦截器注册到容器中
                .addPathPatterns(&quot;&#x2F;**&quot;)  &#x2F;&#x2F;所有请求都被拦截包括静态资源
                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,
                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;); &#x2F;&#x2F;放行的请求
&#125;</code></pre>



<h2 id="49、拦截器-【源码分析】-拦截器的执行时机和原理"><a href="#49、拦截器-【源码分析】-拦截器的执行时机和原理" class="headerlink" title="49、拦截器-【源码分析】-拦截器的执行时机和原理"></a>49、拦截器-【源码分析】-拦截器的执行时机和原理</h2><ol>
<li>根据当前请求，找到<code>HandlerExecutionChain</code>（可以处理请求的handler以及handler的所有 拦截器）</li>
<li>先来顺序执行 所有拦截器的 <code>preHandle()</code>方法。<ul>
<li>如果当前拦截器<code>preHandle()</code>返回为<code>true</code>。则执行下一个拦截器的<code>preHandle()</code></li>
<li>如果当前拦截器返回为<code>false</code>。直接倒序执行所有已经执行了的拦截器的  <code>afterCompletion();</code>。</li>
</ul>
</li>
<li>如果任何一个拦截器返回<code>false</code>，直接跳出不执行目标方法。</li>
<li>所有拦截器都返回<code>true</code>，才执行目标方法。</li>
<li>倒序执行所有拦截器的<code>postHandle()</code>方法。</li>
<li>前面的步骤有任何异常都会直接倒序触发 <code>afterCompletion()</code>。</li>
<li>页面成功渲染完成以后，也会倒序触发 <code>afterCompletion()</code>。</li>
</ol>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211315633.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><code>DispatcherServlet</code>中涉及到<code>HandlerInterceptor</code>的地方：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
    ...
    
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		HttpServletRequest processedRequest &#x3D; request;
		HandlerExecutionChain mappedHandler &#x3D; null;
		boolean multipartRequestParsed &#x3D; false;

		WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);

		try &#123;
			ModelAndView mv &#x3D; null;
			Exception dispatchException &#x3D; null;

            	...
            
                &#x2F;&#x2F;该方法内调用HandlerInterceptor的preHandle()
				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
					return;
				&#125;

				&#x2F;&#x2F; Actually invoke the handler.
				mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());

            	...
                &#x2F;&#x2F;该方法内调用HandlerInterceptor的postHandle()
				mappedHandler.applyPostHandle(processedRequest, response, mv);
			&#125;			
        	processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		&#125;
		catch (Exception ex) &#123;
            &#x2F;&#x2F;该方法内调用HandlerInterceptor接口的afterCompletion方法
			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
		&#125;
		catch (Throwable err) &#123;
            &#x2F;&#x2F;该方法内调用HandlerInterceptor接口的afterCompletion方法
			triggerAfterCompletion(processedRequest, response, mappedHandler,
					new NestedServletException(&quot;Handler processing failed&quot;, err));
		&#125;
		finally &#123;
			...
		&#125;
	&#125;

	private void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, Exception ex) throws Exception &#123;

		if (mappedHandler !&#x3D; null) &#123;
            &#x2F;&#x2F;该方法内调用HandlerInterceptor接口的afterCompletion方法
			mappedHandler.triggerAfterCompletion(request, response, ex);
		&#125;
		throw ex;
	&#125;

	private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception &#123;

        ...

		if (mappedHandler !&#x3D; null) &#123;
            &#x2F;&#x2F;该方法内调用HandlerInterceptor接口的afterCompletion方法
			&#x2F;&#x2F; Exception (if any) is already handled..
			mappedHandler.triggerAfterCompletion(request, response, null);
		&#125;
	&#125;


&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HandlerExecutionChain &#123;
    
    ...
    
	boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		for (int i &#x3D; 0; i &lt; this.interceptorList.size(); i++) &#123;
			HandlerInterceptor interceptor &#x3D; this.interceptorList.get(i);
            &#x2F;&#x2F;HandlerInterceptor的preHandle方法
			if (!interceptor.preHandle(request, response, this.handler)) &#123;
                
				triggerAfterCompletion(request, response, null);
				return false;
			&#125;
			this.interceptorIndex &#x3D; i;
		&#125;
		return true;
	&#125;
    
   	void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)
			throws Exception &#123;

		for (int i &#x3D; this.interceptorList.size() - 1; i &gt;&#x3D; 0; i--) &#123;
			HandlerInterceptor interceptor &#x3D; this.interceptorList.get(i);
            
            &#x2F;&#x2F;HandlerInterceptor接口的postHandle方法
			interceptor.postHandle(request, response, this.handler, mv);
		&#125;
	&#125;
    
    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) &#123;
		for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;
			HandlerInterceptor interceptor &#x3D; this.interceptorList.get(i);
			try &#123;
                &#x2F;&#x2F;HandlerInterceptor接口的afterCompletion方法
				interceptor.afterCompletion(request, response, this.handler, ex);
			&#125;
			catch (Throwable ex2) &#123;
				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);
			&#125;
		&#125;
	&#125;
    
    
&#125; 
    </code></pre>



<h2 id="50、文件上传-单文件与多文件上传的使用"><a href="#50、文件上传-单文件与多文件上传的使用" class="headerlink" title="50、文件上传-单文件与多文件上传的使用"></a>50、文件上传-单文件与多文件上传的使用</h2><ul>
<li>页面代码<code>/static/form/form_layouts.html</code></li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form role&#x3D;&quot;form&quot; th:action&#x3D;&quot;@&#123;&#x2F;upload&#125;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;exampleInputEmail1&quot;&gt;邮箱&lt;&#x2F;label&gt;
        &lt;input type&#x3D;&quot;email&quot; name&#x3D;&quot;email&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;exampleInputEmail1&quot; placeholder&#x3D;&quot;Enter email&quot;&gt;
    &lt;&#x2F;div&gt;
    
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;exampleInputPassword1&quot;&gt;名字&lt;&#x2F;label&gt;
        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;exampleInputPassword1&quot; placeholder&#x3D;&quot;Password&quot;&gt;
    &lt;&#x2F;div&gt;
    
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;头像&lt;&#x2F;label&gt;
        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;headerImg&quot; id&#x3D;&quot;exampleInputFile&quot;&gt;
    &lt;&#x2F;div&gt;
    
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;生活照&lt;&#x2F;label&gt;
        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photos&quot; multiple&gt;
    &lt;&#x2F;div&gt;
    
    &lt;div class&#x3D;&quot;checkbox&quot;&gt;
        &lt;label&gt;
            &lt;input type&#x3D;&quot;checkbox&quot;&gt; Check me out
        &lt;&#x2F;label&gt;
    &lt;&#x2F;div&gt;
    &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;提交&lt;&#x2F;button&gt;
&lt;&#x2F;form&gt;</code></pre>

<ul>
<li>控制层代码</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@Controller
public class FormTestController &#123;

    @GetMapping(&quot;&#x2F;form_layouts&quot;)
    public String form_layouts()&#123;
        return &quot;form&#x2F;form_layouts&quot;;
    &#125;

    @PostMapping(&quot;&#x2F;upload&quot;)
    public String upload(@RequestParam(&quot;email&quot;) String email,
                         @RequestParam(&quot;username&quot;) String username,
                         @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,
                         @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123;

        log.info(&quot;上传的信息：email&#x3D;&#123;&#125;，username&#x3D;&#123;&#125;，headerImg&#x3D;&#123;&#125;，photos&#x3D;&#123;&#125;&quot;,
                 email,username,headerImg.getSize(),photos.length);

        if(!headerImg.isEmpty())&#123;
            &#x2F;&#x2F;保存到文件服务器，OSS服务器
            String originalFilename &#x3D; headerImg.getOriginalFilename();
            headerImg.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));
        &#125;

        if(photos.length &gt; 0)&#123;
            for (MultipartFile photo : photos) &#123;
                if(!photo.isEmpty())&#123;
                    String originalFilename &#x3D; photo.getOriginalFilename();
                    photo.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));
                &#125;
            &#125;
        &#125;


        return &quot;main&quot;;
    &#125;
&#125;</code></pre>



<p>文件上传相关的配置类：</p>
<ul>
<li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</code></li>
<li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartProperties</code></li>
</ul>
<p>文件大小相关配置项：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.servlet.multipart.max-file-size&#x3D;10MB
spring.servlet.multipart.max-request-size&#x3D;100MB</code></pre>

<h2 id="51、文件上传-【源码流程】文件上传参数解析器"><a href="#51、文件上传-【源码流程】文件上传参数解析器" class="headerlink" title="51、文件上传-【源码流程】文件上传参数解析器"></a>51、文件上传-【源码流程】文件上传参数解析器</h2><p>文件上传相关的自动配置类<code>MultipartAutoConfiguration</code>有创建文件上传参数解析器<code>StandardServletMultipartResolver</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class &#125;)
@ConditionalOnProperty(prefix &#x3D; &quot;spring.servlet.multipart&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; true)
@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)
@EnableConfigurationProperties(MultipartProperties.class)
public class MultipartAutoConfiguration &#123;

	private final MultipartProperties multipartProperties;

	public MultipartAutoConfiguration(MultipartProperties multipartProperties) &#123;
		this.multipartProperties &#x3D; multipartProperties;
	&#125;

	@Bean
	@ConditionalOnMissingBean(&#123; MultipartConfigElement.class, CommonsMultipartResolver.class &#125;)
	public MultipartConfigElement multipartConfigElement() &#123;
		return this.multipartProperties.createMultipartConfig();
	&#125;

	@Bean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
	@ConditionalOnMissingBean(MultipartResolver.class)
	public StandardServletMultipartResolver multipartResolver() &#123;
        &#x2F;&#x2F;配置好文件上传解析器
		StandardServletMultipartResolver multipartResolver &#x3D; new StandardServletMultipartResolver();
		multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());
		return multipartResolver;
	&#125;

&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;文件上传解析器
public class StandardServletMultipartResolver implements MultipartResolver &#123;

	private boolean resolveLazily &#x3D; false;

	public void setResolveLazily(boolean resolveLazily) &#123;
		this.resolveLazily &#x3D; resolveLazily;
	&#125;


	@Override
	public boolean isMultipart(HttpServletRequest request) &#123;
		return StringUtils.startsWithIgnoreCase(request.getContentType(), &quot;multipart&#x2F;&quot;);
	&#125;

	@Override
	public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException &#123;
		return new StandardMultipartHttpServletRequest(request, this.resolveLazily);
	&#125;

	@Override
	public void cleanupMultipart(MultipartHttpServletRequest request) &#123;
		if (!(request instanceof AbstractMultipartHttpServletRequest) ||
				((AbstractMultipartHttpServletRequest) request).isResolved()) &#123;
			&#x2F;&#x2F; To be on the safe side: explicitly delete the parts,
			&#x2F;&#x2F; but only actual file parts (for Resin compatibility)
			try &#123;
				for (Part part : request.getParts()) &#123;
					if (request.getFile(part.getName()) !&#x3D; null) &#123;
						part.delete();
					&#125;
				&#125;
			&#125;
			catch (Throwable ex) &#123;
				LogFactory.getLog(getClass()).warn(&quot;Failed to perform cleanup of multipart items&quot;, ex);
			&#125;
		&#125;
	&#125;

&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    
    @Nullable
	private MultipartResolver multipartResolver;
    
	private void initMultipartResolver(ApplicationContext context) &#123;
		...
        
        &#x2F;&#x2F;这个就是配置类配置的StandardServletMultipartResolver文件上传解析器
		this.multipartResolver &#x3D; context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);
		...
	&#125;
    
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		HttpServletRequest processedRequest &#x3D; request;
		HandlerExecutionChain mappedHandler &#x3D; null;
		boolean multipartRequestParsed &#x3D; false;&#x2F;&#x2F;最后finally的回收flag
		...
		try &#123;
			ModelAndView mv &#x3D; null;
			Exception dispatchException &#x3D; null;

			try &#123;
                &#x2F;&#x2F;做预处理,如果有上传文件 就new StandardMultipartHttpServletRequest包装类
				processedRequest &#x3D; checkMultipart(request);
				multipartRequestParsed &#x3D; (processedRequest !&#x3D; request);
				&#x2F;&#x2F; Determine handler for the current request.
				mappedHandler &#x3D; getHandler(processedRequest);
				
                ...

				&#x2F;&#x2F; Determine handler adapter for the current request.
				HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());

				...

				&#x2F;&#x2F; Actually invoke the handler.
				mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());
                
            &#125;
            ....
            
		finally &#123;

            ...
            
            if (multipartRequestParsed) &#123;
                cleanupMultipart(processedRequest);
            &#125;
		&#125;
	&#125;

	protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException &#123;
		if (this.multipartResolver !&#x3D; null &amp;&amp; this.multipartResolver.isMultipart(request)) &#123;
            ...
			return this.multipartResolver.resolveMultipart(request);
            ...
		&#125;
    &#125;

	protected void cleanupMultipart(HttpServletRequest request) &#123;
		if (this.multipartResolver !&#x3D; null) &#123;
			MultipartHttpServletRequest multipartRequest &#x3D;
					WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);
			if (multipartRequest !&#x3D; null) &#123;
				this.multipartResolver.cleanupMultipart(multipartRequest);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>



<p><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>跳到以下的类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean &#123;
	@Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;
		ModelAndView mav;
		...
		mav &#x3D; invokeHandlerMethod(request, response, handlerMethod);
        ...
		return mav;
	&#125;
    
    @Nullable
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

		ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);
		try &#123;
			WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);
			ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);

			ServletInvocableHandlerMethod invocableMethod &#x3D; createInvocableHandlerMethod(handlerMethod);
			if (this.argumentResolvers !&#x3D; null) &#123;&#x2F;&#x2F;关注点
				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
			&#125;
			...
			invocableMethod.invokeAndHandle(webRequest, mavContainer);
			...

			return getModelAndView(mavContainer, modelFactory, webRequest);
		&#125;
		finally &#123;
			webRequest.requestCompleted();
		&#125;
	&#125;
    
&#125;</code></pre>



<p><code>this.argumentResolvers</code>其中主角类<code>RequestPartMethodArgumentResolver</code>用来生成</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123;
    
    ...
	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;
		Object returnValue &#x3D; invokeForRequest(webRequest, mavContainer, providedArgs);
		...
	&#125;
    
	@Nullable
	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

		Object[] args &#x3D; getMethodArgumentValues(request, mavContainer, providedArgs);
		...
		return doInvoke(args);&#x2F;&#x2F;反射调用
	&#125;
    
	@Nullable
	protected Object doInvoke(Object... args) throws Exception &#123;
		Method method &#x3D; getBridgedMethod();
		ReflectionUtils.makeAccessible(method);
		return method.invoke(getBean(), args);
		...
	&#125;
    
    &#x2F;&#x2F;处理得出multipart参数，准备稍后的反射调用（@PostMapping标记的上传方法）
    protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception &#123;

		MethodParameter[] parameters &#x3D; getMethodParameters();
		...
		Object[] args &#x3D; new Object[parameters.length];
		for (int i &#x3D; 0; i &lt; parameters.length; i++) &#123;
			MethodParameter parameter &#x3D; parameters[i];
			parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
			args[i] &#x3D; findProvidedArgument(parameter, providedArgs);
			if (args[i] !&#x3D; null) &#123;
				continue;
			&#125;
            &#x2F;&#x2F;关注点1
			if (!this.resolvers.supportsParameter(parameter)) &#123;
				throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));
			&#125;
			try &#123;
                &#x2F;&#x2F;关注点2
				args[i] &#x3D; this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
			&#125;
			catch (Exception ex) &#123;
				...
			&#125;
		&#125;
		return args;
	&#125;
    
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestPartMethodArgumentResolver extends AbstractMessageConverterMethodArgumentResolver &#123;

    &#x2F;&#x2F;对应上面代码关注点1
    @Override
	public boolean supportsParameter(MethodParameter parameter) &#123;
        &#x2F;&#x2F;标注@RequestPart的参数
		if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;
			return true;
		&#125;
		else &#123;
			if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;
				return false;
			&#125;
			return MultipartResolutionDelegate.isMultipartArgument(parameter.nestedIfOptional());
		&#125;
	&#125;

    &#x2F;&#x2F;对应上面代码关注点2
	@Override
	@Nullable
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest request, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

		HttpServletRequest servletRequest &#x3D; request.getNativeRequest(HttpServletRequest.class);
		Assert.state(servletRequest !&#x3D; null, &quot;No HttpServletRequest&quot;);

		RequestPart requestPart &#x3D; parameter.getParameterAnnotation(RequestPart.class);
		boolean isRequired &#x3D; ((requestPart &#x3D;&#x3D; null || requestPart.required()) &amp;&amp; !parameter.isOptional());

		String name &#x3D; getPartName(parameter, requestPart);
		parameter &#x3D; parameter.nestedIfOptional();
		Object arg &#x3D; null;

        &#x2F;&#x2F;封装成MultipartFile类型的对象作参数
		Object mpArg &#x3D; MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);
		if (mpArg !&#x3D; MultipartResolutionDelegate.UNRESOLVABLE) &#123;
			arg &#x3D; mpArg;
		&#125;
        
        ...

		return adaptArgumentIfNecessary(arg, parameter);
	&#125;
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class MultipartResolutionDelegate &#123;
    ...
    
	@Nullable
	public static Object resolveMultipartArgument(String name, MethodParameter parameter, HttpServletRequest request)
			throws Exception &#123;

		MultipartHttpServletRequest multipartRequest &#x3D;
				WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);
		boolean isMultipart &#x3D; (multipartRequest !&#x3D; null || isMultipartContent(request));

		if (MultipartFile.class &#x3D;&#x3D; parameter.getNestedParameterType()) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			if (multipartRequest &#x3D;&#x3D; null) &#123;
				multipartRequest &#x3D; new StandardMultipartHttpServletRequest(request);
			&#125;
			return multipartRequest.getFile(name);
		&#125;
		else if (isMultipartFileCollection(parameter)) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			if (multipartRequest &#x3D;&#x3D; null) &#123;
				multipartRequest &#x3D; new StandardMultipartHttpServletRequest(request);
			&#125;
			List&lt;MultipartFile&gt; files &#x3D; multipartRequest.getFiles(name);
			return (!files.isEmpty() ? files : null);
		&#125;
		else if (isMultipartFileArray(parameter)) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			if (multipartRequest &#x3D;&#x3D; null) &#123;
				multipartRequest &#x3D; new StandardMultipartHttpServletRequest(request);
			&#125;
			List&lt;MultipartFile&gt; files &#x3D; multipartRequest.getFiles(name);
			return (!files.isEmpty() ? files.toArray(new MultipartFile[0]) : null);
		&#125;
		else if (Part.class &#x3D;&#x3D; parameter.getNestedParameterType()) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			return request.getPart(name);
		&#125;
		else if (isPartCollection(parameter)) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			List&lt;Part&gt; parts &#x3D; resolvePartList(request, name);
			return (!parts.isEmpty() ? parts : null);
		&#125;
		else if (isPartArray(parameter)) &#123;
			if (!isMultipart) &#123;
				return null;
			&#125;
			List&lt;Part&gt; parts &#x3D; resolvePartList(request, name);
			return (!parts.isEmpty() ? parts.toArray(new Part[0]) : null);
		&#125;
		else &#123;
			return UNRESOLVABLE;
		&#125;
	&#125;
    
    ...
    
&#125;</code></pre>



<h2 id="52、错误处理-SpringBoot默认错误处理机制"><a href="#52、错误处理-SpringBoot默认错误处理机制" class="headerlink" title="52、错误处理-SpringBoot默认错误处理机制"></a>52、错误处理-SpringBoot默认错误处理机制</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-error-handling">Spring Boot官方文档 - Error Handling</a></p>
<p><strong>默认规则</strong>：</p>
<ul>
<li><p>默认情况下，Spring Boot提供<code>/error</code>处理所有错误的映射</p>
</li>
<li><p>机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据</p>
</li>
</ul>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
  &quot;timestamp&quot;: &quot;2020-11-22T05:53:28.416+00:00&quot;,
  &quot;status&quot;: 404,
  &quot;error&quot;: &quot;Not Found&quot;,
  &quot;message&quot;: &quot;No message available&quot;,
  &quot;path&quot;: &quot;&#x2F;asadada&quot;
&#125;</code></pre>

<ul>
<li><p>要对其进行自定义，添加<code>View</code>解析为<code>error</code></p>
</li>
<li><p>要完全替换默认行为，可以实现 <code>ErrorController </code>并注册该类型的Bean定义，或添加<code>ErrorAttributes类型的组件</code>以使用现有机制但替换其内容。</p>
</li>
<li><p><code>/templates/error/</code>下的4xx，5xx页面会被自动解析</p>
</li>
</ul>
<h2 id="53、错误处理-【源码分析】底层组件功能分析"><a href="#53、错误处理-【源码分析】底层组件功能分析" class="headerlink" title="53、错误处理-【源码分析】底层组件功能分析"></a>53、错误处理-【源码分析】底层组件功能分析</h2><ul>
<li><code>ErrorMvcAutoConfiguration</code>  自动配置异常处理规则</li>
<li><strong>容器中的组件</strong>：类型：<code>DefaultErrorAttributes</code> -&gt; id：<code>errorAttributes</code></li>
<li><code>public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver</code><ul>
<li><code>DefaultErrorAttributes</code>：定义错误页面中可以包含数据（异常明细，堆栈信息等）。</li>
</ul>
</li>
<li><strong>容器中的组件</strong>：类型：<code>BasicErrorController</code> –&gt; id：<code>basicErrorController</code>（json+白页 适配响应）</li>
<li><strong>处理默认 <code>/error</code> 路径的请求</strong>，页面响应 <code>new ModelAndView(&quot;error&quot;, model);</code><ul>
<li>容器中有组件 <code>View</code>-&gt;id是error；（响应默认错误页）</li>
<li>容器中放组件 <code>BeanNameViewResolver</code>（视图解析器）；按照返回的视图名作为组件的id去容器中找<code>View</code>对象。</li>
</ul>
</li>
<li><strong>容器中的组件</strong>：类型：<code>DefaultErrorViewResolver</code> -&gt; id：<code>conventionErrorViewResolver</code></li>
<li><strong>如果发生异常错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面</strong>（主要作用）。<ul>
<li>error&#x2F;404、5xx.html</li>
<li>如果想要返回页面，就会找error视图（<code>StaticView</code>默认是一个白页）。</li>
</ul>
</li>
</ul>
<h2 id="54、错误处理-【源码流程】异常处理流程"><a href="#54、错误处理-【源码流程】异常处理流程" class="headerlink" title="54、错误处理-【源码流程】异常处理流程"></a>54、错误处理-【源码流程】异常处理流程</h2><p>譬如写一个会抛出异常的控制层：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@RestController
public class HelloController &#123;

    @RequestMapping(&quot;&#x2F;hello&quot;)
    public String handle01()&#123;

        int i &#x3D; 1 &#x2F; 0;&#x2F;&#x2F;将会抛出ArithmeticException

        log.info(&quot;Hello, Spring Boot 2!&quot;);
        return &quot;Hello, Spring Boot 2!&quot;;
    &#125;
&#125;</code></pre>

<p>当浏览器发出<code>/hello</code>请求，<code>DispatcherServlet</code>的<code>doDispatch()</code>的<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>将会抛出<code>ArithmeticException</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DispatcherServlet extends FrameworkServlet &#123;
    ...
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		...
				&#x2F;&#x2F; Actually invoke the handler.
            	&#x2F;&#x2F;将会抛出ArithmeticException
				mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());

				applyDefaultViewName(processedRequest, mv);
				mappedHandler.applyPostHandle(processedRequest, response, mv);
			&#125;
			catch (Exception ex) &#123;
                &#x2F;&#x2F;将会捕捉ArithmeticException
				dispatchException &#x3D; ex;
			&#125;
			catch (Throwable err) &#123;
				...
			&#125;
    		&#x2F;&#x2F;捕捉后，继续运行
			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		&#125;
		catch (Exception ex) &#123;
			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
		&#125;
		catch (Throwable err) &#123;
			triggerAfterCompletion(processedRequest, response, mappedHandler,
					new NestedServletException(&quot;Handler processing failed&quot;, err));
		&#125;
		finally &#123;
			...
		&#125;
	&#125;

	private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception &#123;

		boolean errorView &#x3D; false;

		if (exception !&#x3D; null) &#123;
			if (exception instanceof ModelAndViewDefiningException) &#123;
				...
			&#125;
			else &#123;
				Object handler &#x3D; (mappedHandler !&#x3D; null ? mappedHandler.getHandler() : null);
				&#x2F;&#x2F;ArithmeticException将在这处理
                mv &#x3D; processHandlerException(request, response, handler, exception);
				errorView &#x3D; (mv !&#x3D; null);
			&#125;
		&#125;
		...
	&#125;

	protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
			@Nullable Object handler, Exception ex) throws Exception &#123;

		&#x2F;&#x2F; Success and error responses may use different content types
		request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);

		&#x2F;&#x2F; Check registered HandlerExceptionResolvers...
		ModelAndView exMv &#x3D; null;
		if (this.handlerExceptionResolvers !&#x3D; null) &#123;
            &#x2F;&#x2F;遍历所有的 handlerExceptionResolvers，看谁能处理当前异常HandlerExceptionResolver处理器异常解析器
			for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) &#123;
				exMv &#x3D; resolver.resolveException(request, response, handler, ex);
				if (exMv !&#x3D; null) &#123;
					break;
				&#125;
			&#125;
		&#125;
		...
	
        &#x2F;&#x2F;若只有系统的自带的异常解析器（没有自定义的），异常还是会抛出
		throw ex;
	&#125;

&#125;</code></pre>

<p>系统自带的<strong>异常解析器</strong>：</p>
<p><img src="https://typora-xyy.oss-cn-nanjing.aliyuncs.com/imgs/202207211315638.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li><code>DefaultErrorAttributes</code>先来处理异常，它主要功能把异常信息保存到request域，并且返回null。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123;
    ...
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;
        this.storeErrorAttributes(request, ex);
        return null;
    &#125;

    private void storeErrorAttributes(HttpServletRequest request, Exception ex) &#123;
        request.setAttribute(ERROR_ATTRIBUTE, ex);&#x2F;&#x2F;把异常信息保存到request域
    &#125;
    ...
    
&#125;    </code></pre>

<ul>
<li><p>默认没有任何解析器（上图的<code>HandlerExceptionResolverComposite</code>）能处理异常，所以最后异常会被抛出。</p>
</li>
<li><p>最终底层就会转发<code>/error</code> 请求。会被底层的<code>BasicErrorController</code>处理。</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:&#x2F;error&#125;&#125;&quot;)
public class BasicErrorController extends AbstractErrorController &#123;

    @RequestMapping(produces &#x3D; MediaType.TEXT_HTML_VALUE)
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;
       HttpStatus status &#x3D; getStatus(request);
       Map&lt;String, Object&gt; model &#x3D; Collections
             .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));
       response.setStatus(status.value());
       ModelAndView modelAndView &#x3D; resolveErrorView(request, response, status, model);
       &#x2F;&#x2F;如果&#x2F;template&#x2F;error内没有4**.html或5**.html，
       &#x2F;&#x2F;modelAndView为空，最终还是返回viewName为error的modelAndView
       return (modelAndView !&#x3D; null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);
    &#125;
    
    ...
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    
    ...
    
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        ...
     	&#x2F;&#x2F; Actually invoke the handler.
		mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());
		...
        &#x2F;&#x2F;渲染页面
		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
        ...
    &#125;
    
    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
			@Nullable Exception exception) throws Exception &#123;

        boolean errorView &#x3D; false;
        ...
		&#x2F;&#x2F; Did the handler return a view to render?
		if (mv !&#x3D; null &amp;&amp; !mv.wasCleared()) &#123;
			render(mv, request, response);
			if (errorView) &#123;
				WebUtils.clearErrorRequestAttributes(request);
			&#125;
		&#125;
		...
	&#125;
    
    protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
		...

		View view;
		String viewName &#x3D; mv.getViewName();
		if (viewName !&#x3D; null) &#123;
			&#x2F;&#x2F; We need to resolve the view name.
            &#x2F;&#x2F;找出合适error的View，如果&#x2F;template&#x2F;error内没有4**.html或5**.html，
            &#x2F;&#x2F;将会返回默认异常页面ErrorMvcAutoConfiguration.StaticView
            &#x2F;&#x2F;这里按需深究代码吧！
			view &#x3D; resolveViewName(viewName, mv.getModelInternal(), locale, request);
			...
		&#125;
		...
		try &#123;
			if (mv.getStatus() !&#x3D; null) &#123;
				response.setStatus(mv.getStatus().value());
			&#125;
            &#x2F;&#x2F;看下面代码块的StaticView的render块
			view.render(mv.getModelInternal(), request, response);
		&#125;
		catch (Exception ex) &#123;
			...
		&#125;
	&#125;
    
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class &#125;)
&#x2F;&#x2F; Load before the main WebMvcAutoConfiguration so that the error View is available
@AutoConfigureBefore(WebMvcAutoConfiguration.class)
@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class, WebMvcProperties.class &#125;)
public class ErrorMvcAutoConfiguration &#123;
    
    ...
        
   	@Configuration(proxyBeanMethods &#x3D; false)
	@ConditionalOnProperty(prefix &#x3D; &quot;server.error.whitelabel&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; true)
	@Conditional(ErrorTemplateMissingCondition.class)
	protected static class WhitelabelErrorViewConfiguration &#123;

        &#x2F;&#x2F;将创建一个名为error的系统默认异常页面View的Bean
		private final StaticView defaultErrorView &#x3D; new StaticView();

		@Bean(name &#x3D; &quot;error&quot;)
		@ConditionalOnMissingBean(name &#x3D; &quot;error&quot;)
		public View defaultErrorView() &#123;
			return this.defaultErrorView;
		&#125;

		&#x2F;&#x2F; If the user adds @EnableWebMvc then the bean name view resolver from
		&#x2F;&#x2F; WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.
		@Bean
		@ConditionalOnMissingBean
		public BeanNameViewResolver beanNameViewResolver() &#123;
			BeanNameViewResolver resolver &#x3D; new BeanNameViewResolver();
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
			return resolver;
		&#125;

	&#125;     
   
    
	private static class StaticView implements View &#123;

		private static final MediaType TEXT_HTML_UTF8 &#x3D; new MediaType(&quot;text&quot;, &quot;html&quot;, StandardCharsets.UTF_8);

		private static final Log logger &#x3D; LogFactory.getLog(StaticView.class);

		@Override
		public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)
				throws Exception &#123;
			if (response.isCommitted()) &#123;
				String message &#x3D; getMessage(model);
				logger.error(message);
				return;
			&#125;
			response.setContentType(TEXT_HTML_UTF8.toString());
			StringBuilder builder &#x3D; new StringBuilder();
			Object timestamp &#x3D; model.get(&quot;timestamp&quot;);
			Object message &#x3D; model.get(&quot;message&quot;);
			Object trace &#x3D; model.get(&quot;trace&quot;);
			if (response.getContentType() &#x3D;&#x3D; null) &#123;
				response.setContentType(getContentType());
			&#125;
            &#x2F;&#x2F;系统默认异常页面html代码
			builder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;&#x2F;h1&gt;&quot;).append(
					&quot;&lt;p&gt;This application has no explicit mapping for &#x2F;error, so you are seeing this as a fallback.&lt;&#x2F;p&gt;&quot;)
					.append(&quot;&lt;div id&#x3D;&#39;created&#39;&gt;&quot;).append(timestamp).append(&quot;&lt;&#x2F;div&gt;&quot;)
					.append(&quot;&lt;div&gt;There was an unexpected error (type&#x3D;&quot;).append(htmlEscape(model.get(&quot;error&quot;)))
					.append(&quot;, status&#x3D;&quot;).append(htmlEscape(model.get(&quot;status&quot;))).append(&quot;).&lt;&#x2F;div&gt;&quot;);
			if (message !&#x3D; null) &#123;
				builder.append(&quot;&lt;div&gt;&quot;).append(htmlEscape(message)).append(&quot;&lt;&#x2F;div&gt;&quot;);
			&#125;
			if (trace !&#x3D; null) &#123;
				builder.append(&quot;&lt;div style&#x3D;&#39;white-space:pre-wrap;&#39;&gt;&quot;).append(htmlEscape(trace)).append(&quot;&lt;&#x2F;div&gt;&quot;);
			&#125;
			builder.append(&quot;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;);
			response.getWriter().append(builder.toString());
		&#125;

		private String htmlEscape(Object input) &#123;
			return (input !&#x3D; null) ? HtmlUtils.htmlEscape(input.toString()) : null;
		&#125;

		private String getMessage(Map&lt;String, ?&gt; model) &#123;
			Object path &#x3D; model.get(&quot;path&quot;);
			String message &#x3D; &quot;Cannot render error page for request [&quot; + path + &quot;]&quot;;
			if (model.get(&quot;message&quot;) !&#x3D; null) &#123;
				message +&#x3D; &quot; and exception [&quot; + model.get(&quot;message&quot;) + &quot;]&quot;;
			&#125;
			message +&#x3D; &quot; as the response has already been committed.&quot;;
			message +&#x3D; &quot; As a result, the response may have the wrong status code.&quot;;
			return message;
		&#125;

		@Override
		public String getContentType() &#123;
			return &quot;text&#x2F;html&quot;;
		&#125;

	&#125;
&#125;</code></pre>



<h2 id="55、错误处理-【源码流程】几种异常处理原理"><a href="#55、错误处理-【源码流程】几种异常处理原理" class="headerlink" title="55、错误处理-【源码流程】几种异常处理原理"></a>55、错误处理-【源码流程】几种异常处理原理</h2><ul>
<li><p>自定义错误页</p>
<ul>
<li>error&#x2F;404.html   error&#x2F;5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页</li>
</ul>
</li>
<li><p><code>@ControllerAdvice</code>+<code>@ExceptionHandler</code>处理全局异常；底层是 <code>ExceptionHandlerExceptionResolver</code> 支持的</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler &#123;

    @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;)  &#x2F;&#x2F;处理异常
    public String handleArithException(Exception e)&#123;

        log.error(&quot;异常是：&#123;&#125;&quot;,e);
        return &quot;login&quot;; &#x2F;&#x2F;视图地址
    &#125;
&#125;</code></pre>

<ul>
<li><code>@ResponseStatus</code>+自定义异常 ；底层是 <code>ResponseStatusExceptionResolver</code> ，把responseStatus注解的信息底层调用 <code>response.sendError(statusCode, resolvedReason)</code>，tomcat发送的<code>/error</code></li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ResponseStatus(value&#x3D; HttpStatus.FORBIDDEN,reason &#x3D; &quot;用户数量太多&quot;)
public class UserTooManyException extends RuntimeException &#123;

    public  UserTooManyException()&#123;

    &#125;
    public  UserTooManyException(String message)&#123;
        super(message);
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class TableController &#123;
    
	@GetMapping(&quot;&#x2F;dynamic_table&quot;)
    public String dynamic_table(@RequestParam(value&#x3D;&quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;) Integer pn,Model model)&#123;
        &#x2F;&#x2F;表格内容的遍历
	     List&lt;User&gt; users &#x3D; Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),
                new User(&quot;lisi&quot;, &quot;123444&quot;),
                new User(&quot;haha&quot;, &quot;aaaaa&quot;),
                new User(&quot;hehe &quot;, &quot;aaddd&quot;));
        model.addAttribute(&quot;users&quot;,users);

        if(users.size()&gt;3)&#123;
            throw new UserTooManyException();&#x2F;&#x2F;抛出自定义异常
        &#125;
        return &quot;table&#x2F;dynamic_table&quot;;
    &#125;
    
&#125;</code></pre>

<ul>
<li><p>Spring自家异常如 <code> org.springframework.web.bind.MissingServletRequestParameterException</code>，<code>DefaultHandlerExceptionResolver</code> 处理Spring自家异常。</p>
</li>
<li><ul>
<li><code>response.sendError(HttpServletResponse.SC_BAD_REQUEST/*400*/, ex.getMessage());</code></li>
</ul>
</li>
<li><p>自定义实现 <code>HandlerExceptionResolver</code> 处理异常；可以作为默认的全局异常处理规则</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Order(value&#x3D; Ordered.HIGHEST_PRECEDENCE)  &#x2F;&#x2F;优先级，数字越小优先级越高
@Component
public class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler, Exception ex) &#123;

        try &#123;
            response.sendError(511,&quot;我喜欢的错误&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return new ModelAndView();
    &#125;
&#125;</code></pre>

<ul>
<li><code>ErrorViewResolver</code>  实现自定义处理异常<ul>
<li><code>response.sendError()</code>，error请求就会转给controller。</li>
<li>你的异常没有任何人能处理，tomcat底层调用<code>response.sendError()</code>，error请求就会转给controller。</li>
<li><code>basicErrorController</code> 要去的页面地址是 <code>ErrorViewResolver</code>  。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:&#x2F;error&#125;&#125;&quot;)
public class BasicErrorController extends AbstractErrorController &#123;

    ...
    
	@RequestMapping(produces &#x3D; MediaType.TEXT_HTML_VALUE)
	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;
		HttpStatus status &#x3D; getStatus(request);
		Map&lt;String, Object&gt; model &#x3D; Collections
				.unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));
		response.setStatus(status.value());
		ModelAndView modelAndView &#x3D; resolveErrorView(request, response, status, model);
		return (modelAndView !&#x3D; null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);
	&#125;
    
    protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status,
			Map&lt;String, Object&gt; model) &#123;
        &#x2F;&#x2F;这里用到ErrorViewResolver接口
		for (ErrorViewResolver resolver : this.errorViewResolvers) &#123;
			ModelAndView modelAndView &#x3D; resolver.resolveErrorView(request, status, model);
			if (modelAndView !&#x3D; null) &#123;
				return modelAndView;
			&#125;
		&#125;
		return null;
	&#125;
    
    ...
    
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">@FunctionalInterface
public interface ErrorViewResolver &#123;

	ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model);

&#125;</code></pre>



<h2 id="56、原生组件注入-原生注解与Spring方式注入"><a href="#56、原生组件注入-原生注解与Spring方式注入" class="headerlink" title="56、原生组件注入-原生注解与Spring方式注入"></a>56、原生组件注入-原生注解与Spring方式注入</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener">官方文档 - Servlets, Filters, and listeners</a></p>
<h3 id="使用原生的注解"><a href="#使用原生的注解" class="headerlink" title="使用原生的注解"></a>使用原生的注解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet(urlPatterns &#x3D; &quot;&#x2F;my&quot;)
public class MyServlet extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        resp.getWriter().write(&quot;66666&quot;);
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@WebFilter(urlPatterns&#x3D;&#123;&quot;&#x2F;css&#x2F;*&quot;,&quot;&#x2F;images&#x2F;*&quot;&#125;) &#x2F;&#x2F;my
public class MyFilter implements Filter &#123;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        log.info(&quot;MyFilter初始化完成&quot;);
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        log.info(&quot;MyFilter工作&quot;);
        chain.doFilter(request,response);
    &#125;

    @Override
    public void destroy() &#123;
        log.info(&quot;MyFilter销毁&quot;);
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@WebListener
public class MyServletContextListener implements ServletContextListener &#123;


    @Override
    public void contextInitialized(ServletContextEvent sce) &#123;
        log.info(&quot;MySwervletContextListener监听到项目初始化完成&quot;);
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent sce) &#123;
        log.info(&quot;MySwervletContextListener监听到项目销毁&quot;);
    &#125;
&#125;</code></pre>

<p>最后还要在主启动类添加注解<code>@ServletComponentScan</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ServletComponentScan(basePackages &#x3D; &quot;com.lun&quot;)&#x2F;&#x2F;
@SpringBootApplication(exclude &#x3D; RedisAutoConfiguration.class)
public class Boot05WebAdminApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Boot05WebAdminApplication.class, args);
    &#125;
&#125;</code></pre>



<h3 id="Spring方式注入"><a href="#Spring方式注入" class="headerlink" title="Spring方式注入"></a>Spring方式注入</h3><p><code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, and <code>ServletListenerRegistrationBean</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration(proxyBeanMethods &#x3D; true)
public class MyRegistConfig &#123;

    @Bean
    public ServletRegistrationBean myServlet()&#123;
        MyServlet myServlet &#x3D; new MyServlet();

        return new ServletRegistrationBean(myServlet,&quot;&#x2F;my&quot;,&quot;&#x2F;my02&quot;);
    &#125;


    @Bean
    public FilterRegistrationBean myFilter()&#123;

        MyFilter myFilter &#x3D; new MyFilter();
&#x2F;&#x2F;        return new FilterRegistrationBean(myFilter,myServlet());
        FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean(myFilter);
        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;my&quot;,&quot;&#x2F;css&#x2F;*&quot;));
        return filterRegistrationBean;
    &#125;

    @Bean
    public ServletListenerRegistrationBean myListener()&#123;
        MySwervletContextListener mySwervletContextListener &#x3D; new MySwervletContextListener();
        return new ServletListenerRegistrationBean(mySwervletContextListener);
    &#125;
&#125;</code></pre>



<h2 id="57、原生组件注入-【源码分析】DispatcherServlet注入原理"><a href="#57、原生组件注入-【源码分析】DispatcherServlet注入原理" class="headerlink" title="57、原生组件注入-【源码分析】DispatcherServlet注入原理"></a>57、原生组件注入-【源码分析】DispatcherServlet注入原理</h2><p><code>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</code>配置类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration(proxyBeanMethods &#x3D; false)
@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration &#123;

	&#x2F;*
	 * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;&#x2F;&quot;
	 *&#x2F;
	public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME &#x3D; &quot;dispatcherServlet&quot;;

	&#x2F;*
	 * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;&#x2F;&quot;
	 *&#x2F;
	public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME &#x3D; &quot;dispatcherServletRegistration&quot;;

	@Configuration(proxyBeanMethods &#x3D; false)
	@Conditional(DefaultDispatcherServletCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	protected static class DispatcherServletConfiguration &#123;

        &#x2F;&#x2F;创建DispatcherServlet类的Bean
		@Bean(name &#x3D; DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) &#123;
			DispatcherServlet dispatcherServlet &#x3D; new DispatcherServlet();
			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
			dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());
			dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());
			dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());
			dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());
			return dispatcherServlet;
		&#125;

		@Bean
		@ConditionalOnBean(MultipartResolver.class)
		@ConditionalOnMissingBean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
		public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;
			&#x2F;&#x2F; Detect if the user has created a MultipartResolver but named it incorrectly
			return resolver;
		&#125;

	&#125;
    
    @Configuration(proxyBeanMethods &#x3D; false)
	@Conditional(DispatcherServletRegistrationCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	@Import(DispatcherServletConfiguration.class)
	protected static class DispatcherServletRegistrationConfiguration &#123;

        &#x2F;&#x2F;注册DispatcherServlet类
		@Bean(name &#x3D; DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		@ConditionalOnBean(value &#x3D; DispatcherServlet.class, name &#x3D; DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,
				WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) &#123;
			DispatcherServletRegistrationBean registration &#x3D; new DispatcherServletRegistrationBean(dispatcherServlet,
					webMvcProperties.getServlet().getPath());
			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
			registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
			multipartConfig.ifAvailable(registration::setMultipartConfig);
			return registration;
		&#125;

	&#125;
    
    ...
    
&#125;</code></pre>

<p><code>DispatcherServlet</code>默认映射的是 <code>/</code> 路径，可以通过在配置文件修改<code>spring.mvc.servlet.path=/mvc</code>。</p>
<h2 id="58、嵌入式Servlet容器-【源码分析】切换web服务器与定制化"><a href="#58、嵌入式Servlet容器-【源码分析】切换web服务器与定制化" class="headerlink" title="58、嵌入式Servlet容器-【源码分析】切换web服务器与定制化"></a>58、嵌入式Servlet容器-【源码分析】切换web服务器与定制化</h2><ul>
<li><p>默认支持的WebServer</p>
<ul>
<li><code>Tomcat</code>, <code>Jetty</code>, or <code>Undertow</code>。</li>
<li><code>ServletWebServerApplicationContext </code>容器启动寻找<code>ServletWebServerFactory</code> 并引导创建服务器。</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>SpringBoot应用启动发现当前是Web应用，web场景包-导入tomcat。</li>
<li>web应用会创建一个web版的IOC容器 <code>ServletWebServerApplicationContext</code> 。</li>
<li><code>ServletWebServerApplicationContext</code>  启动的时候寻找 <code>ServletWebServerFactory</code> （Servlet 的web服务器工厂——&gt;Servlet 的web服务器）。</li>
<li>SpringBoot底层默认有很多的WebServer工厂（<code>ServletWebServerFactoryConfiguration</code>内创建Bean），如：<ul>
<li><code>TomcatServletWebServerFactory</code></li>
<li><code>JettyServletWebServerFactory</code></li>
<li><code>UndertowServletWebServerFactory</code></li>
</ul>
</li>
<li>底层直接会有一个自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>。</li>
<li><code>ServletWebServerFactoryAutoConfiguration</code>导入了<code>ServletWebServerFactoryConfiguration</code>（配置类）。</li>
<li><code>ServletWebServerFactoryConfiguration  </code>根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 <code>TomcatServletWebServerFactory</code></li>
<li><code>TomcatServletWebServerFactory </code>创建出Tomcat服务器并启动；<code>TomcatWebServer</code> 的构造器拥有初始化方法initialize——<code>this.tomcat.start();</code></li>
<li>内嵌服务器，与以前手动把启动服务器相比，改成现在使用代码启动（tomcat核心jar包存在）。</li>
</ul>
</li>
</ul>
<p>Spring Boot默认使用Tomcat服务器，若需更改其他服务器，则修改工程pom.xml：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;exclusion&gt;
    &lt;&#x2F;exclusions&gt;
&lt;&#x2F;dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;
</code></pre>

<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#howto-use-another-web-server">官方文档 - Use Another Web Server</a></p>
<h3 id="定制Servlet容器"><a href="#定制Servlet容器" class="headerlink" title="定制Servlet容器"></a>定制Servlet容器</h3><ul>
<li><p>实现<code>WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;</code> </p>
</li>
<li><ul>
<li>把配置文件的值和<code>ServletWebServerFactory</code>进行绑定</li>
</ul>
</li>
<li><p>修改配置文件 <code>server.xxx</code></p>
</li>
<li><p>直接自定义 <code>ConfigurableServletWebServerFactory</code></p>
</li>
</ul>
<p><code>xxxxxCustomizer</code>：定制化器，可以改变xxxx的默认规则</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;

    @Override
    public void customize(ConfigurableServletWebServerFactory server) &#123;
        server.setPort(9000);
    &#125;

&#125;</code></pre>



<h2 id="59、定制化原理-SpringBoot定制化组件的几种方式（小结）"><a href="#59、定制化原理-SpringBoot定制化组件的几种方式（小结）" class="headerlink" title="59、定制化原理-SpringBoot定制化组件的几种方式（小结）"></a>59、定制化原理-SpringBoot定制化组件的几种方式（小结）</h2><h3 id="定制化的常见方式"><a href="#定制化的常见方式" class="headerlink" title="定制化的常见方式"></a>定制化的常见方式</h3><ul>
<li><p>修改配置文件</p>
</li>
<li><p><code>xxxxxCustomizer</code></p>
</li>
<li><p>编写自定义的配置类  <code>xxxConfiguration</code> + <code>@Bean</code>替换、增加容器中默认组件，视图解析器</p>
</li>
<li><p>Web应用 编写一个配置类实现 <code>WebMvcConfigurer</code> 即可定制化web功能 + <code>@Bean</code>给容器中再扩展一些组件</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class AdminWebConfig implements WebMvcConfigurer&#123;
&#125;</code></pre>

<ul>
<li><code>@EnableWebMvc</code> + <code>WebMvcConfigurer</code> — <code>@Bean</code>  可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能（<strong>高级功能，初学者退避三舍</strong>）。<ul>
<li>原理：<ol>
<li><code>WebMvcAutoConfiguration</code>默认的SpringMVC的自动配置功能类，如静态资源、欢迎页等。</li>
<li>一旦使用 <code>@EnableWebMvc</code> ，会<code>@Import(DelegatingWebMvcConfiguration.class)</code>。</li>
<li><code>DelegatingWebMvcConfiguration</code>的作用，只保证SpringMVC最基本的使用<ul>
<li>把所有系统中的<code>WebMvcConfigurer</code>拿过来，所有功能的定制都是这些<code>WebMvcConfigurer</code>合起来一起生效。</li>
<li>自动配置了一些非常底层的组件，如<code>RequestMappingHandlerMapping</code>，这些组件依赖的组件都是从容器中获取如。</li>
<li><code>public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport</code>。</li>
</ul>
</li>
<li><code>WebMvcAutoConfiguration</code>里面的配置要能生效必须  <code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>。</li>
<li>@EnableWebMvc 导致了WebMvcAutoConfiguration  没有生效。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="原理分析套路"><a href="#原理分析套路" class="headerlink" title="原理分析套路"></a>原理分析套路</h3><p>场景starter - <code>xxxxAutoConfiguration</code> - 导入xxx组件 - 绑定<code>xxxProperties</code> - 绑定配置文件项。</p>
<h2 id="60、数据访问-数据库场景的自动配置分析与整合测试"><a href="#60、数据访问-数据库场景的自动配置分析与整合测试" class="headerlink" title="60、数据访问-数据库场景的自动配置分析与整合测试"></a>60、数据访问-数据库场景的自动配置分析与整合测试</h2><h3 id="导入JDBC场景"><a href="#导入JDBC场景" class="headerlink" title="导入JDBC场景"></a>导入JDBC场景</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>接着导入数据库驱动包（MySQL为例）。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--默认版本：--&gt;
&lt;mysql.version&gt;8.0.22&lt;&#x2F;mysql.version&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
    &lt;!--&lt;version&gt;5.1.49&lt;&#x2F;version&gt;--&gt;
&lt;&#x2F;dependency&gt;

&lt;!--
想要修改版本
1、直接依赖引入具体版本（maven的就近依赖原则）
2、重新声明版本（maven的属性的就近优先原则）
--&gt;
&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;
    &lt;mysql.version&gt;5.1.49&lt;&#x2F;mysql.version&gt;
&lt;&#x2F;properties&gt;</code></pre>



<h3 id="相关数据源配置类"><a href="#相关数据源配置类" class="headerlink" title="相关数据源配置类"></a>相关数据源配置类</h3><ul>
<li><p><code>DataSourceAutoConfiguration</code> ： 数据源的自动配置。</p>
<ul>
<li>修改数据源相关的配置：<code>spring.datasource</code>。</li>
<li><strong>数据库连接池的配置，是自己容器中没有DataSource才自动配置的</strong>。</li>
<li>底层配置好的连接池是：<code>HikariDataSource</code>。</li>
</ul>
</li>
<li><p><code>DataSourceTransactionManagerAutoConfiguration</code>： 事务管理器的自动配置。</p>
</li>
<li><p><code>JdbcTemplateAutoConfiguration</code>： <code>JdbcTemplate</code>的自动配置，可以来对数据库进行CRUD。</p>
<ul>
<li>可以修改前缀为<code>spring.jdbc</code>的配置项来修改<code>JdbcTemplate</code>。</li>
<li><code>@Bean @Primary JdbcTemplate</code>：Spring容器中有这个<code>JdbcTemplate</code>组件，使用<code>@Autowired</code>。</li>
</ul>
</li>
<li><p><code>JndiDataSourceAutoConfiguration</code>： JNDI的自动配置。</p>
</li>
<li><p><code>XADataSourceAutoConfiguration</code>： 分布式事务相关的。</p>
</li>
</ul>
<h3 id="修改配置项"><a href="#修改配置项" class="headerlink" title="修改配置项"></a>修改配置项</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver</code></pre>



<h3 id="单元测试数据源"><a href="#单元测试数据源" class="headerlink" title="单元测试数据源"></a>单元测试数据源</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;

@SpringBootTest
class Boot05WebAdminApplicationTests &#123;

    @Autowired
    JdbcTemplate jdbcTemplate;

    @Test&#x2F;&#x2F;用@org.junit.Test会报空指针异常，可能跟JUnit新版本有关
    void contextLoads() &#123;
&#x2F;&#x2F;        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)
&#x2F;&#x2F;        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)
        Long aLong &#x3D; jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class);
        log.info(&quot;记录总数：&#123;&#125;&quot;,aLong);
    &#125;

&#125;</code></pre>



<h2 id="61、数据访问-自定义方式整合druid数据源"><a href="#61、数据访问-自定义方式整合druid数据源" class="headerlink" title="61、数据访问-自定义方式整合druid数据源"></a>61、数据访问-自定义方式整合druid数据源</h2><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid">Druid官网</a></p>
<h3 id="Druid是什么？"><a href="#Druid是什么？" class="headerlink" title="Druid是什么？"></a>Druid是什么？</h3><p>它是数据库连接池，它能够提供强大的监控和扩展功能。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D">官方文档 - Druid连接池介绍</a></p>
<p>Spring Boot整合第三方技术的两种方式：</p>
<ul>
<li><p>自定义</p>
</li>
<li><p>找starter场景</p>
</li>
</ul>
<h3 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h3><p><strong>添加依赖</strong>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.1.17&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p><strong>配置Druid数据源</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class MyConfig &#123;

    @Bean
    @ConfigurationProperties(&quot;spring.datasource&quot;)&#x2F;&#x2F;复用配置文件的数据源配置
    public DataSource dataSource() throws SQLException &#123;
        DruidDataSource druidDataSource &#x3D; new DruidDataSource();

&#x2F;&#x2F;        druidDataSource.setUrl();
&#x2F;&#x2F;        druidDataSource.setUsername();
&#x2F;&#x2F;        druidDataSource.setPassword();

        return druidDataSource;
    &#125;
&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE">更多配置项</a></p>
<p><strong>配置Druid的监控页功能</strong>：</p>
<ul>
<li><p>Druid内置提供了一个<code>StatViewServlet</code>用于展示Druid的统计信息。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE">官方文档 - 配置_StatViewServlet配置</a>。这个<code>StatViewServlet</code>的用途包括：</p>
<ul>
<li>提供监控信息展示的html页面</li>
<li>提供监控信息的JSON API</li>
</ul>
</li>
<li><p>Druid内置提供一个<code>StatFilter</code>，用于统计监控信息。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter">官方文档 - 配置_StatFilter</a></p>
</li>
<li><p><code>WebStatFilter</code>用于采集web-jdbc关联监控的数据，如SQL监控、URI监控。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter">官方文档 - 配置_配置WebStatFilter</a></p>
</li>
<li><p>Druid提供了<code>WallFilter</code>，它是基于SQL语义分析来实现防御SQL注入攻击的。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter">官方文档 - 配置 wallfilter</a></p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class MyConfig &#123;

    @Bean
    @ConfigurationProperties(&quot;spring.datasource&quot;)
    public DataSource dataSource() throws SQLException &#123;
        DruidDataSource druidDataSource &#x3D; new DruidDataSource();

        &#x2F;&#x2F;加入监控和防火墙功能功能
        druidDataSource.setFilters(&quot;stat,wall&quot;);
        
        return druidDataSource;
    &#125;
    
    &#x2F;**
     * 配置 druid的监控页功能
     * @return
     *&#x2F;
    @Bean
    public ServletRegistrationBean statViewServlet()&#123;
        StatViewServlet statViewServlet &#x3D; new StatViewServlet();
        ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean &#x3D; 
            new ServletRegistrationBean&lt;&gt;(statViewServlet, &quot;&#x2F;druid&#x2F;*&quot;);

        &#x2F;&#x2F;监控页账号密码：
        registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);
        registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;);

        return registrationBean;
    &#125;
    
     &#x2F;**
     * WebStatFilter 用于采集web-jdbc关联监控的数据。
     *&#x2F;
    @Bean
    public FilterRegistrationBean webStatFilter()&#123;
        WebStatFilter webStatFilter &#x3D; new WebStatFilter();

        FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean &#x3D; new FilterRegistrationBean&lt;&gt;(webStatFilter);
        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;));
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&quot;);

        return filterRegistrationBean;
    &#125;
    
&#125;</code></pre>



<h2 id="62、数据访问-druid数据源starter整合方式"><a href="#62、数据访问-druid数据源starter整合方式" class="headerlink" title="62、数据访问-druid数据源starter整合方式"></a>62、数据访问-druid数据源starter整合方式</h2><p><a href="">官方文档 - Druid Spring Boot Starter</a></p>
<p><strong>引入依赖</strong>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.1.17&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p><strong>分析自动配置</strong>：</p>
<ul>
<li>扩展配置项 <code>spring.datasource.druid</code></li>
<li>自动配置类<code>DruidDataSourceAutoConfigure</code></li>
<li><code>DruidSpringAopConfiguration.class</code>,  监控SpringBean的；配置项：<code>spring.datasource.druid.aop-patterns</code></li>
<li><code>DruidStatViewServletConfiguration.class</code>, 监控页的配置。<code>spring.datasource.druid.stat-view-servlet</code>默认开启。</li>
<li><code>DruidWebStatFilterConfiguration.class</code>，web监控配置。<code>spring.datasource.druid.web-stat-filter</code>默认开启。</li>
<li><code>DruidFilterConfiguration.class</code>所有Druid的filter的配置：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final String FILTER_STAT_PREFIX &#x3D; &quot;spring.datasource.druid.filter.stat&quot;;
private static final String FILTER_CONFIG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.config&quot;;
private static final String FILTER_ENCODING_PREFIX &#x3D; &quot;spring.datasource.druid.filter.encoding&quot;;
private static final String FILTER_SLF4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.slf4j&quot;;
private static final String FILTER_LOG4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j&quot;;
private static final String FILTER_LOG4J2_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j2&quot;;
private static final String FILTER_COMMONS_LOG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.commons-log&quot;;
private static final String FILTER_WALL_PREFIX &#x3D; &quot;spring.datasource.druid.filter.wall&quot;;</code></pre>

<p><strong>配置示例</strong>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: &#x2F;*
        exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&#39;


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false</code></pre>



<h2 id="63、数据访问-整合MyBatis-配置版"><a href="#63、数据访问-整合MyBatis-配置版" class="headerlink" title="63、数据访问-整合MyBatis-配置版"></a>63、数据访问-整合MyBatis-配置版</h2><p><a target="_blank" rel="noopener" href="https://github.com/mybatis">MyBatis的GitHub仓库</a></p>
<p><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis官方</a></p>
<p><strong>starter的命名方式</strong>：</p>
<ol>
<li>SpringBoot官方的Starter：<code>spring-boot-starter-*</code></li>
<li>第三方的： <code>*-spring-boot-starter</code></li>
</ol>
<p><strong>引入依赖</strong>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.1.4&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p><strong>配置模式</strong>:</p>
<ul>
<li><p>全局配置文件</p>
</li>
<li><p><code>SqlSessionFactory</code>：自动配置好了</p>
</li>
<li><p><code>SqlSession</code>：自动配置了<code>SqlSessionTemplate</code> 组合了<code>SqlSession</code></p>
</li>
<li><p><code>@Import(AutoConfiguredMapperScannerRegistrar.class)</code></p>
</li>
<li><p><code>Mapper</code>： 只要我们写的操作MyBatis的接口标准了<code>@Mapper</code>就会被自动扫描进来</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。
@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)
public class MybatisAutoConfiguration&#123;
    ...
&#125;

@ConfigurationProperties(prefix &#x3D; &quot;mybatis&quot;)
public class MybatisProperties&#123;
    ...
&#125;</code></pre>

<hr>
<p><strong>配置文件</strong>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;my
    driver-class-name: com.mysql.jdbc.Driver

# 配置mybatis规则
mybatis:
  config-location: classpath:mybatis&#x2F;mybatis-config.xml  #全局配置文件位置
  mapper-locations: classpath:mybatis&#x2F;*.xml  #sql映射文件位置</code></pre>



<p><strong>mybatis-config.xml</strong>:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
	
    &lt;!-- 由于Spring Boot自动配置缘故，此处不必配置，只用来做做样。--&gt;
&lt;&#x2F;configuration&gt;</code></pre>



<p><strong>Mapper接口</strong>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace&#x3D;&quot;com.lun.boot.mapper.UserMapper&quot;&gt;

    &lt;select id&#x3D;&quot;getUser&quot; resultType&#x3D;&quot;com.lun.boot.bean.User&quot;&gt;
        select * from user where id&#x3D;#&#123;id&#125;
    &lt;&#x2F;select&gt;
&lt;&#x2F;mapper&gt;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.boot.bean.User;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper &#123;
    public User getUser(Integer id);
&#125;</code></pre>



<p><strong>POJO</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User &#123;
    private Integer id;
    private String name;
    
	&#x2F;&#x2F;getters and setters...
&#125;</code></pre>



<p><strong>DB</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;user&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;name&#96; varchar(45) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8mb4;</code></pre>



<p><strong>Controller and Service</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController &#123;

    @Autowired
    private UserService userService;

    @ResponseBody
    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Integer id)&#123;

        return userService.getUser(id);
    &#125;

&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class UserService &#123;

    @Autowired
    private UserMapper userMapper;&#x2F;&#x2F;IDEA下标红线，可忽视这红线

    public User getUser(Integer id)&#123;
        return userMapper.getUser(id);
    &#125;

&#125;</code></pre>



<p>配置<code>private Configuration configuration;</code> 也就是配置<code>mybatis.configuration</code>相关的，就是相当于改mybatis全局配置文件中的值。（也就是说配置了<code>mybatis.configuration</code>，就不需配置mybatis全局配置文件了）</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 配置mybatis规则
mybatis:
  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml
  # 可以不写全局配置文件，所有全局配置文件的配置都放在configuration配置项中了。
  # config-location: classpath:mybatis&#x2F;mybatis-config.xml
  configuration:
    map-underscore-to-camel-case: true</code></pre>



<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>导入MyBatis官方Starter。</li>
<li>编写Mapper接口，需<code>@Mapper</code>注解。</li>
<li>编写SQL映射文件并绑定Mapper接口。</li>
<li>在<code>application.yaml</code>中指定Mapper配置文件的所处位置，以及指定全局配置文件的信息 （建议：**配置在<code>mybatis.configuration</code>**）。</li>
</ul>
<h2 id="64、数据访问-整合MyBatis-注解配置混合版"><a href="#64、数据访问-整合MyBatis-注解配置混合版" class="headerlink" title="64、数据访问-整合MyBatis-注解配置混合版"></a>64、数据访问-整合MyBatis-注解配置混合版</h2><p>你可以通过Spring Initializr添加MyBatis的Starer。</p>
<p><strong>注解与配置混合搭配，干活不累</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper
public interface UserMapper &#123;
    public User getUser(Integer id);

    @Select(&quot;select * from user where id&#x3D;#&#123;id&#125;&quot;)
    public User getUser2(Integer id);

    public void saveUser(User user);

    @Insert(&quot;insert into user(&#96;name&#96;) values(#&#123;name&#125;)&quot;)
    @Options(useGeneratedKeys &#x3D; true, keyProperty &#x3D; &quot;id&quot;)
    public void saveUser2(User user);

&#125;
</code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace&#x3D;&quot;com.lun.boot.mapper.UserMapper&quot;&gt;

    &lt;select id&#x3D;&quot;getUser&quot; resultType&#x3D;&quot;com.lun.boot.bean.User&quot;&gt;
        select * from user where id&#x3D;#&#123;id&#125;
    &lt;&#x2F;select&gt;

    &lt;insert id&#x3D;&quot;saveUser&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;
        insert into user(&#96;name&#96;) values(#&#123;name&#125;)
    &lt;&#x2F;insert&gt;

&lt;&#x2F;mapper&gt;</code></pre>



<ul>
<li><p>简单DAO方法就写在注解上。复杂的就写在配置文件里。</p>
</li>
<li><p>使用<code>@MapperScan(&quot;com.lun.boot.mapper&quot;)</code> 简化，Mapper接口就可以不用标注<code>@Mapper</code>注解。</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@MapperScan(&quot;com.lun.boot.mapper&quot;)
@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class, args);
    &#125;

&#125;</code></pre>



<h2 id="65、数据访问-整合MyBatisPlus操作数据库"><a href="#65、数据访问-整合MyBatisPlus操作数据库" class="headerlink" title="65、数据访问-整合MyBatisPlus操作数据库"></a>65、数据访问-整合MyBatisPlus操作数据库</h2><p><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10119-mybatisx">IDEA的MyBatis的插件 - MyBatisX</a></p>
<p><a target="_blank" rel="noopener" href="https://baomidou.com/">MyBatisPlus官网</a></p>
<p><a target="_blank" rel="noopener" href="https://baomidou.com/guide/">MyBatisPlus官方文档</a></p>
<h3 id="MyBatisPlus是什么"><a href="#MyBatisPlus是什么" class="headerlink" title="MyBatisPlus是什么"></a>MyBatisPlus是什么</h3><p><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<hr>
<p>添加依赖：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li><p><code>MybatisPlusAutoConfiguration</code>配置类，<code>MybatisPlusProperties</code>配置项绑定。</p>
</li>
<li><p><code>SqlSessionFactory</code>自动配置好，底层是容器中默认的数据源。</p>
</li>
<li><p><code>mapperLocations</code>自动配置好的，有默认值<code>classpath*:/mapper/**/*.xml</code>，这表示任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。  建议以后sql映射文件放在 mapper下。</p>
</li>
<li><p>容器中也自动配置好了<code>SqlSessionTemplate</code>。</p>
</li>
<li><p><code>@Mapper</code> 标注的接口也会被自动扫描，建议直接 <code>@MapperScan(&quot;com.lun.boot.mapper&quot;)</code>批量扫描。</p>
</li>
<li><p>MyBatisPlus<strong>优点</strong>之一：只需要我们的Mapper继承MyBatisPlus的<code>BaseMapper</code> 就可以拥有CRUD能力，减轻开发工作。</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.lun.hellomybatisplus.model.User;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;

&#125;</code></pre>



<h2 id="66、数据访问-CRUD实验-数据列表展示"><a href="#66、数据访问-CRUD实验-数据列表展示" class="headerlink" title="66、数据访问-CRUD实验-数据列表展示"></a>66、数据访问-CRUD实验-数据列表展示</h2><p><a target="_blank" rel="noopener" href="https://baomidou.com/guide/crud-interface.html">官方文档 - CRUD接口</a></p>
<p>使用MyBatis Plus提供的<code>IService</code>，<code>ServiceImpl</code>，减轻Service层开发工作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.hellomybatisplus.model.User;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

&#x2F;**
 *  Service 的CRUD也不用写了
 *&#x2F;
public interface UserService extends IService&lt;User&gt; &#123;
	&#x2F;&#x2F;此处故意为空
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.hellomybatisplus.model.User;
import com.lun.hellomybatisplus.mapper.UserMapper;
import com.lun.hellomybatisplus.service.UserService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;
	&#x2F;&#x2F;此处故意为空
&#125;</code></pre>

<p>与下一节联合在一起</p>
<h2 id="67、数据访问-CRUD实验-分页数据展示"><a href="#67、数据访问-CRUD实验-分页数据展示" class="headerlink" title="67、数据访问-CRUD实验-分页数据展示"></a>67、数据访问-CRUD实验-分页数据展示</h2><p>与下一节联合在一起</p>
<h2 id="68、数据访问-CRUD实验-删除用户完成"><a href="#68、数据访问-CRUD实验-删除用户完成" class="headerlink" title="68、数据访问-CRUD实验-删除用户完成"></a>68、数据访问-CRUD实验-删除用户完成</h2><p>添加分页插件：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class MyBatisConfig &#123;


    &#x2F;**
     * MybatisPlusInterceptor
     * @return
     *&#x2F;
    @Bean
    public MybatisPlusInterceptor paginationInterceptor() &#123;
        MybatisPlusInterceptor mybatisPlusInterceptor &#x3D; new MybatisPlusInterceptor();
        &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
        &#x2F;&#x2F; paginationInterceptor.setOverflow(false);
        &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制
        &#x2F;&#x2F; paginationInterceptor.setLimit(500);
        &#x2F;&#x2F; 开启 count 的 join 优化,只针对部分 left join

        &#x2F;&#x2F;这是分页拦截器
        PaginationInnerInterceptor paginationInnerInterceptor &#x3D; new PaginationInnerInterceptor();
        paginationInnerInterceptor.setOverflow(true);
        paginationInnerInterceptor.setMaxLimit(500L);
        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);

        return mybatisPlusInterceptor;
    &#125;
&#125;</code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table class&#x3D;&quot;display table table-bordered table-striped&quot; id&#x3D;&quot;dynamic-table&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;#&lt;&#x2F;th&gt;
            &lt;th&gt;name&lt;&#x2F;th&gt;
            &lt;th&gt;age&lt;&#x2F;th&gt;
            &lt;th&gt;email&lt;&#x2F;th&gt;
            &lt;th&gt;操作&lt;&#x2F;th&gt;
        &lt;&#x2F;tr&gt;
    &lt;&#x2F;thead&gt;
    &lt;tbody&gt;
        &lt;tr class&#x3D;&quot;gradeX&quot; th:each&#x3D;&quot;user: $&#123;users.records&#125;&quot;&gt;
            &lt;td th:text&#x3D;&quot;$&#123;user.id&#125;&quot;&gt;&lt;&#x2F;td&gt;
            &lt;td&gt;[[$&#123;user.name&#125;]]&lt;&#x2F;td&gt;
            &lt;td th:text&#x3D;&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;&#x2F;td&gt;
            &lt;td th:text&#x3D;&quot;$&#123;user.email&#125;&quot;&gt;4&lt;&#x2F;td&gt;
            &lt;td&gt;
                &lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;delete&#x2F;&#123;id&#125;(id&#x3D;$&#123;user.id&#125;,pn&#x3D;$&#123;users.current&#125;)&#125;&quot; 
                   class&#x3D;&quot;btn btn-danger btn-sm&quot; type&#x3D;&quot;button&quot;&gt;删除&lt;&#x2F;a&gt;
            &lt;&#x2F;td&gt;
        &lt;&#x2F;tr&gt;
    &lt;&#x2F;tfoot&gt;
&lt;&#x2F;table&gt;

&lt;div class&#x3D;&quot;row-fluid&quot;&gt;
    &lt;div class&#x3D;&quot;span6&quot;&gt;
        &lt;div class&#x3D;&quot;dataTables_info&quot; id&#x3D;&quot;dynamic-table_info&quot;&gt;
            当前第[[$&#123;users.current&#125;]]页  总计 [[$&#123;users.pages&#125;]]页  共[[$&#123;users.total&#125;]]条记录
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;span6&quot;&gt;
        &lt;div class&#x3D;&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;
            &lt;ul&gt;
                &lt;li class&#x3D;&quot;prev disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;← 前一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
                &lt;li th:class&#x3D;&quot;$&#123;num &#x3D;&#x3D; users.current?&#39;active&#39;:&#39;&#39;&#125;&quot; 
                    th:each&#x3D;&quot;num:$&#123;#numbers.sequence(1,users.pages)&#125;&quot; &gt;
                    &lt;a th:href&#x3D;&quot;@&#123;&#x2F;dynamic_table(pn&#x3D;$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;&#x2F;a&gt;
                &lt;&#x2F;li&gt;
                &lt;li class&#x3D;&quot;next disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;下一页 → &lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
            &lt;&#x2F;ul&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
</code></pre>

<p><code>#numbers</code>表示methods for formatting numeric objects.<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#expression-utility-objects">link</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;user&#x2F;delete&#x2F;&#123;id&#125;&quot;)
public String deleteUser(@PathVariable(&quot;id&quot;) Long id,
                         @RequestParam(value &#x3D; &quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;)Integer pn,
                         RedirectAttributes ra)&#123;

    userService.removeById(id);

    ra.addAttribute(&quot;pn&quot;,pn);
    return &quot;redirect:&#x2F;dynamic_table&quot;;
&#125;

@GetMapping(&quot;&#x2F;dynamic_table&quot;)
public String dynamic_table(@RequestParam(value&#x3D;&quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;) Integer pn,Model model)&#123;
    &#x2F;&#x2F;表格内容的遍历

    &#x2F;&#x2F;从数据库中查出user表中的用户进行展示

    &#x2F;&#x2F;构造分页参数
    Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(pn, 2);
    &#x2F;&#x2F;调用page进行分页
    Page&lt;User&gt; userPage &#x3D; userService.page(page, null);

    model.addAttribute(&quot;users&quot;,userPage);

    return &quot;table&#x2F;dynamic_table&quot;;
&#125;</code></pre>

<h2 id="69、数据访问-准备阿里云Redis环境"><a href="#69、数据访问-准备阿里云Redis环境" class="headerlink" title="69、数据访问-准备阿里云Redis环境"></a>69、数据访问-准备阿里云Redis环境</h2><p><strong>添加依赖</strong>：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;

&lt;!--导入jedis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li><code>RedisAutoConfiguration</code>自动配置类，RedisProperties 属性类 –&gt; spring.redis.xxx是对redis的配置。</li>
<li>连接工厂<code>LettuceConnectionConfiguration</code>、<code>JedisConnectionConfiguration</code>是准备好的。</li>
<li>自动注入了<code>RedisTemplate&lt;Object, Object&gt;</code>，<code>xxxTemplate</code>。</li>
<li>自动注入了<code>StringRedisTemplate</code>，key，value都是String</li>
<li>底层只要我们使用<code>StringRedisTemplate</code>、<code>RedisTemplate</code>就可以操作Redis。</li>
</ul>
<p><strong>外网Redis环境搭建</strong>：</p>
<ol>
<li><p>阿里云按量付费Redis，其中选择<strong>经典网络</strong>。</p>
</li>
<li><p>申请Redis的公网连接地址。</p>
</li>
<li><p>修改白名单，允许<code>0.0.0.0/0</code>访问。</p>
</li>
</ol>
<h2 id="70、数据访问-Redis操作与统计小实验"><a href="#70、数据访问-Redis操作与统计小实验" class="headerlink" title="70、数据访问-Redis操作与统计小实验"></a>70、数据访问-Redis操作与统计小实验</h2><p>相关Redis配置：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">spring:
  redis:
#   url: redis:&#x2F;&#x2F;lfy:Lfy123456@r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com:6379
    host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com
    port: 6379
    password: lfy:Lfy123456
    client-type: jedis
    jedis:
      pool:
        max-active: 10
#   lettuce:# 另一个用来连接redis的java框架
#      pool:
#        max-active: 10
#        min-idle: 5</code></pre>

<p>测试Redis连接：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTest
public class Boot05WebAdminApplicationTests &#123;

    @Autowired
    StringRedisTemplate redisTemplate;


    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    @Test
    void testRedis()&#123;
        ValueOperations&lt;String, String&gt; operations &#x3D; redisTemplate.opsForValue();

        operations.set(&quot;hello&quot;,&quot;world&quot;);

        String hello &#x3D; operations.get(&quot;hello&quot;);
        System.out.println(hello);

        System.out.println(redisConnectionFactory.getClass());
    &#125;

&#125;</code></pre>



<p>Redis Desktop Manager：可视化Redis管理软件。</p>
<p>URL统计拦截器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
public class RedisUrlCountInterceptor implements HandlerInterceptor &#123;

    @Autowired
    StringRedisTemplate redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        String uri &#x3D; request.getRequestURI();

        &#x2F;&#x2F;默认每次访问当前uri就会计数+1
        redisTemplate.opsForValue().increment(uri);

        return true;
    &#125;
&#125;</code></pre>



<p>注册URL统计拦截器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class AdminWebConfig implements WebMvcConfigurer&#123;

    @Autowired
    RedisUrlCountInterceptor redisUrlCountInterceptor;


    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;

        registry.addInterceptor(redisUrlCountInterceptor)
                .addPathPatterns(&quot;&#x2F;**&quot;)
                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,
                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;);
    &#125;
&#125;</code></pre>



<p>Filter、Interceptor 几乎拥有相同的功能？</p>
<ul>
<li>Filter是Servlet定义的原生组件，它的好处是脱离Spring应用也能使用。</li>
<li>Interceptor是Spring定义的接口，可以使用Spring的自动装配等功能。</li>
</ul>
<p>调用Redis内的统计数据：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
@Controller
public class IndexController &#123;

	@Autowired
    StringRedisTemplate redisTemplate;
    
	@GetMapping(&quot;&#x2F;main.html&quot;)
    public String mainPage(HttpSession session,Model model)&#123;

        log.info(&quot;当前方法是：&#123;&#125;&quot;,&quot;mainPage&quot;);

        ValueOperations&lt;String, String&gt; opsForValue &#x3D;
                redisTemplate.opsForValue();

        String s &#x3D; opsForValue.get(&quot;&#x2F;main.html&quot;);
        String s1 &#x3D; opsForValue.get(&quot;&#x2F;sql&quot;);

        model.addAttribute(&quot;mainCount&quot;,s);
        model.addAttribute(&quot;sqlCount&quot;,s1);

        return &quot;main&quot;;
    &#125;
&#125;</code></pre>



<h2 id="71、单元测试-JUnit5简介"><a href="#71、单元测试-JUnit5简介" class="headerlink" title="71、单元测试-JUnit5简介"></a>71、单元测试-JUnit5简介</h2><p><strong>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</strong></p>
<p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">JUnit 5官方文档</a></p>
<p>作为最新版本的JUnit框架，JUnit5与之前版本的JUnit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<p><strong>JUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p>
<ul>
<li><p><strong>JUnit Platform</strong>: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p>
</li>
<li><p><strong>JUnit Jupiter</strong>: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。</p>
</li>
<li><p><strong>JUnit Vintage</strong>: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x，JUnit3.x的测试引擎。</p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li><p>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容JUnit4需要自行引入（不能使用JUnit4的功能 @Test）</p>
</li>
<li><p>JUnit 5’s Vintage已经从<code>spring-boot-starter-test</code>从移除。如果需要继续兼容Junit4需要自行引入Vintage依赖：</p>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;
    &lt;scope&gt;test&lt;&#x2F;scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;exclusion&gt;
    &lt;&#x2F;exclusions&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li>使用添加JUnit 5，添加对应的starter：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;
    &lt;scope&gt;test&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li>Spring的JUnit 5的基本单元测试模板（Spring的JUnit4的是<code>@SpringBootTest</code>+<code>@RunWith(SpringRunner.class)</code>）：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;&#x2F;&#x2F;注意不是org.junit.Test（这是JUnit4版本的）
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootApplicationTests &#123;

    @Autowired
    private Component component;
    
    @Test
    &#x2F;&#x2F;@Transactional 标注后连接数据库有回滚功能
    public void contextLoads() &#123;
		Assertions.assertEquals(5, component.getFive());
    &#125;
&#125;</code></pre>


<blockquote>
<p>Jupiter</p>
<p>英 [ˈdʒuːpɪtə(r)]   美 [ˈdʒuːpɪtər]</p>
<p>n. 木星(太阳系中最大的行星)</p>
</blockquote>
<blockquote>
<p>vintage</p>
<p>英 [ˈvɪntɪdʒ]   美 [ˈvɪntɪdʒ]</p>
<p>n. 特定年份(或地方)酿制的酒;酿造年份;采摘葡萄酿酒的期间(或季节);葡萄收获期(或季节)</p>
<p>adj. (指葡萄酒)优质的，上等的，佳酿的;古色古香的(指1917–1930年间制造，车型和品味受人青睐的);(过去某个时期)典型的，优质的;(某人的)最佳作品的</p>
</blockquote>
<h2 id="72、单元测试-常用测试注解"><a href="#72、单元测试-常用测试注解" class="headerlink" title="72、单元测试-常用测试注解"></a>72、单元测试-常用测试注解</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">官方文档 - Annotations</a></p>
<ul>
<li><strong>@Test</strong>：表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li><strong>@ParameterizedTest</strong>：表示方法是参数化测试。</li>
<li><strong>@RepeatedTest</strong>：表示方法可重复执行。</li>
<li><strong>@DisplayName</strong>：为测试类或者测试方法设置展示名称。</li>
<li><strong>@BeforeEach</strong>：表示在<strong>每个</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong>@AfterEach</strong>：表示在<strong>每个</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong>@BeforeAll</strong>：表示在<strong>所有</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong>@AfterAll</strong>：表示在<strong>所有</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong>@Tag</strong>：表示单元测试类别，类似于JUnit4中的@Categories。</li>
<li><strong>@Disabled</strong>：表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。</li>
<li><strong>@Timeout</strong>：表示测试方法运行如果超过了指定时间将会返回错误。</li>
<li><strong>@ExtendWith</strong>：为测试类或测试方法提供扩展类引用。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.*;

@DisplayName(&quot;junit5功能测试类&quot;)
public class Junit5Test &#123;


    @DisplayName(&quot;测试displayname注解&quot;)
    @Test
    void testDisplayName() &#123;
        System.out.println(1);
        System.out.println(jdbcTemplate);
    &#125;
    
    @ParameterizedTest
    @ValueSource(strings &#x3D; &#123; &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; &#125;)
    void palindromes(String candidate) &#123;
        assertTrue(StringUtils.isPalindrome(candidate));
    &#125;
    

    @Disabled
    @DisplayName(&quot;测试方法2&quot;)
    @Test
    void test2() &#123;
        System.out.println(2);
    &#125;

    @RepeatedTest(5)
    @Test
    void test3() &#123;
        System.out.println(5);
    &#125;

    &#x2F;**
     * 规定方法超时时间。超出时间测试出异常
     *
     * @throws InterruptedException
     *&#x2F;
    @Timeout(value &#x3D; 500, unit &#x3D; TimeUnit.MILLISECONDS)
    @Test
    void testTimeout() throws InterruptedException &#123;
        Thread.sleep(600);
    &#125;


    @BeforeEach
    void testBeforeEach() &#123;
        System.out.println(&quot;测试就要开始了...&quot;);
    &#125;

    @AfterEach
    void testAfterEach() &#123;
        System.out.println(&quot;测试结束了...&quot;);
    &#125;

    @BeforeAll
    static void testBeforeAll() &#123;
        System.out.println(&quot;所有测试就要开始了...&quot;);
    &#125;

    @AfterAll
    static void testAfterAll() &#123;
        System.out.println(&quot;所有测试以及结束了...&quot;);

    &#125;

&#125;</code></pre>



<h2 id="73、单元测试-断言机制"><a href="#73、单元测试-断言机制" class="headerlink" title="73、单元测试-断言机制"></a>73、单元测试-断言机制</h2><p>断言Assertion是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是org.junit.jupiter.api.Assertions的静态方法。检查业务逻辑返回的数据是否合理。所有的测试运行结束以后，会有一个详细的测试报告。</p>
<p>JUnit 5 内置的断言可以分成如下几个类别：</p>
<h3 id="简单断言"><a href="#简单断言" class="headerlink" title="简单断言"></a>简单断言</h3><p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;simple assertion&quot;)
public void simple() &#123;
     assertEquals(3, 1 + 2, &quot;simple math&quot;);
     assertNotEquals(3, 1 + 1);

     assertNotSame(new Object(), new Object());
     Object obj &#x3D; new Object();
     assertSame(obj, obj);

     assertFalse(1 &gt; 2);
     assertTrue(1 &lt; 2);

     assertNull(null);
     assertNotNull(new Object());
&#125;</code></pre>



<h3 id="数组断言"><a href="#数组断言" class="headerlink" title="数组断言"></a>数组断言</h3><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;array assertion&quot;)
public void array() &#123;
	assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);
&#125;</code></pre>



<h3 id="组合断言"><a href="#组合断言" class="headerlink" title="组合断言"></a>组合断言</h3><p><code>assertAll()</code>方法接受多个 <code>org.junit.jupiter.api.Executable</code> 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;assert all&quot;)
public void all() &#123;
 assertAll(&quot;Math&quot;,
    () -&gt; assertEquals(2, 1 + 1),
    () -&gt; assertTrue(1 &gt; 0)
 );
&#125;</code></pre>

<h3 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h3><p>在JUnit4时期，想要测试方法的异常情况时，需要用<code>@Rule</code>注解的<code>ExpectedException</code>变量还是比较麻烦的。而JUnit5提供了一种新的断言方式<code>Assertions.assertThrows()</code>，配合函数式编程就可以进行使用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;异常测试&quot;)
public void exceptionTest() &#123;
    ArithmeticException exception &#x3D; Assertions.assertThrows(
           &#x2F;&#x2F;扔出断言异常
            ArithmeticException.class, () -&gt; System.out.println(1 % 0));
&#125;</code></pre>

<h3 id="超时断言"><a href="#超时断言" class="headerlink" title="超时断言"></a>超时断言</h3><p>JUnit5还提供了Assertions.assertTimeout()为测试方法设置了超时时间。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;超时测试&quot;)
public void timeoutTest() &#123;
    &#x2F;&#x2F;如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));
&#125;</code></pre>

<h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p>通过 fail 方法直接使得测试失败。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
@DisplayName(&quot;fail&quot;)
public void shouldFail() &#123;
	fail(&quot;This should fail&quot;);
&#125;</code></pre>



<h2 id="74、单元测试-前置条件"><a href="#74、单元测试-前置条件" class="headerlink" title="74、单元测试-前置条件"></a>74、单元测试-前置条件</h2><p>Unit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的<strong>断言assertions</strong>会使得测试方法失败，而<strong>不满足的前置条件只会使得测试方法的执行终止</strong>。</p>
<p>前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@DisplayName(&quot;前置条件&quot;)
public class AssumptionsTest &#123;
    private final String environment &#x3D; &quot;DEV&quot;;

    @Test
    @DisplayName(&quot;simple&quot;)
    public void simpleAssume() &#123;
        assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));
        assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;));
    &#125;

    @Test
    @DisplayName(&quot;assume then do&quot;)
    public void assumeThenDo() &#123;
        assumingThat(
            Objects.equals(this.environment, &quot;DEV&quot;),
            () -&gt; System.out.println(&quot;In DEV&quot;)
        );
    &#125;
&#125;</code></pre>

<p><code>assumeTrue</code> 和 <code>assumFalse</code> 确保给定的条件为 <code>true</code> 或 <code>false</code>，不满足条件会使得测试执行终止。</p>
<p><code>assumingThat</code> 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，<code>Executable</code> 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h2 id="75、单元测试-嵌套测试"><a href="#75、单元测试-嵌套测试" class="headerlink" title="75、单元测试-嵌套测试"></a>75、单元测试-嵌套测试</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">官方文档 - Nested Tests</a></p>
<p>JUnit 5 可以通过 Java 中的内部类和<code>@Nested</code> 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用<code>@BeforeEach</code> 和<code>@AfterEach</code>注解，而且嵌套的层次没有限制。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@DisplayName(&quot;A stack&quot;)
class TestingAStackDemo &#123;

    Stack&lt;Object&gt; stack;

    @Test
    @DisplayName(&quot;is instantiated with new Stack()&quot;)
    void isInstantiatedWithNew() &#123;
        new Stack&lt;&gt;();
    &#125;

    @Nested
    @DisplayName(&quot;when new&quot;)
    class WhenNew &#123;

        @BeforeEach
        void createNewStack() &#123;
            stack &#x3D; new Stack&lt;&gt;();
        &#125;

        @Test
        @DisplayName(&quot;is empty&quot;)
        void isEmpty() &#123;
            assertTrue(stack.isEmpty());
        &#125;

        @Test
        @DisplayName(&quot;throws EmptyStackException when popped&quot;)
        void throwsExceptionWhenPopped() &#123;
            assertThrows(EmptyStackException.class, stack::pop);
        &#125;

        @Test
        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)
        void throwsExceptionWhenPeeked() &#123;
            assertThrows(EmptyStackException.class, stack::peek);
        &#125;

        @Nested
        @DisplayName(&quot;after pushing an element&quot;)
        class AfterPushing &#123;

            String anElement &#x3D; &quot;an element&quot;;

            @BeforeEach
            void pushAnElement() &#123;
                stack.push(anElement);
            &#125;

            @Test
            @DisplayName(&quot;it is no longer empty&quot;)
            void isNotEmpty() &#123;
                assertFalse(stack.isEmpty());
            &#125;

            @Test
            @DisplayName(&quot;returns the element when popped and is empty&quot;)
            void returnElementWhenPopped() &#123;
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            &#125;

            @Test
            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)
            void returnElementWhenPeeked() &#123;
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            &#125;
        &#125;
    &#125;
&#125;</code></pre>



<h2 id="76、单元测试-参数化测试"><a href="#76、单元测试-参数化测试" class="headerlink" title="76、单元测试-参数化测试"></a>76、单元测试-参数化测试</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">官方文档 - Parameterized Tests</a></p>
<p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p>
<p>利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<ul>
<li><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li>
<li><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</li>
<li><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</li>
<li><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</li>
<li><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</li>
</ul>
<p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现**<code>ArgumentsProvider</code>**接口，任何外部文件都可以作为它的入参。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ParameterizedTest
@ValueSource(strings &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)
@DisplayName(&quot;参数化测试1&quot;)
public void parameterizedTest1(String string) &#123;
    System.out.println(string);
    Assertions.assertTrue(StringUtils.isNotBlank(string));
&#125;


@ParameterizedTest
@MethodSource(&quot;method&quot;)    &#x2F;&#x2F;指定方法名
@DisplayName(&quot;方法来源参数&quot;)
public void testWithExplicitLocalMethodSource(String name) &#123;
    System.out.println(name);
    Assertions.assertNotNull(name);
&#125;

static Stream&lt;String&gt; method() &#123;
    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);
&#125;</code></pre>

<h3 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a>迁移指南</h3><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4">官方文档 - Migrating from JUnit 4</a></p>
<p>在进行迁移的时候需要注意如下的变化：</p>
<ul>
<li>注解在 <code>org.junit.jupiter.api</code> 包中，断言在 <code>org.junit.jupiter.api.Assertions</code> 类中，前置条件在 <code>org.junit.jupiter.api.Assumptions</code> 类中。</li>
<li>把<code>@Before</code> 和<code>@After</code> 替换成<code>@BeforeEach</code> 和<code>@AfterEach</code>。</li>
<li>把<code>@BeforeClass</code> 和<code>@AfterClass</code> 替换成<code>@BeforeAll</code> 和@AfterAll。</li>
<li>把<code>@Ignore</code> 替换成<code>@Disabled</code>。</li>
<li>把<code>@Category</code> 替换成<code>@Tag</code>。</li>
<li>把<code>@RunWith</code>、<code>@Rule</code> 和<code>@ClassRule</code> 替换成<code>@ExtendWith</code>。</li>
</ul>
<h2 id="77、指标监控-SpringBoot-Actuator与Endpoint"><a href="#77、指标监控-SpringBoot-Actuator与Endpoint" class="headerlink" title="77、指标监控-SpringBoot Actuator与Endpoint"></a>77、指标监控-SpringBoot Actuator与Endpoint</h2><p>未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready">官方文档 - Spring Boot Actuator: Production-ready Features</a></p>
<p><strong>1.x与2.x的不同</strong>：</p>
<ul>
<li><p>SpringBoot Actuator 1.x</p>
<ul>
<li>支持SpringMVC</li>
<li>基于继承方式进行扩展</li>
<li>层级Metrics配置</li>
<li>自定义Metrics收集</li>
<li>默认较少的安全策略</li>
</ul>
</li>
<li><p>SpringBoot Actuator 2.x</p>
<ul>
<li>支持SpringMVC、JAX-RS以及Webflux</li>
<li>注解驱动进行扩展</li>
<li>层级&amp;名称空间Metrics</li>
<li>底层使用MicroMeter，强大、便捷默认丰富的安全策略</li>
</ul>
</li>
</ul>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul>
<li>添加依赖：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<ul>
<li>访问<code>http://localhost:8080/actuator/**</code>。</li>
<li>暴露所有监控信息为HTTP。</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: &#39;*&#39;  #以web方式暴露</code></pre>

<ul>
<li>测试例子<ul>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/beans">http://localhost:8080/actuator/beans</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/configprops">http://localhost:8080/actuator/configprops</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/metrics">http://localhost:8080/actuator/metrics</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/metrics/jvm.gc.pause">http://localhost:8080/actuator/metrics/jvm.gc.pause</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/metrics/endpointName/detailPath">http://localhost:8080/actuator/metrics/endpointName/detailPath</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>actuator</p>
<p>英 [ˈæktjʊeɪtə]   美 [ˈæktjuˌeɪtər]</p>
<p>n. 致动（促动，激励，调节）器；传动（装置，机构）；拖动装置；马达；操作机构；执行机构（元件）；（电磁铁）螺线管；操纵装置（阀门）；调速控制器；往复运动油（气）缸；作动筒</p>
</blockquote>
<blockquote>
<p>metric</p>
<p>英 [ˈmetrɪk]   美 [ˈmetrɪk]</p>
<p>adj. 米制的;公制的;按公制制作的;用公制测量的</p>
<p>n. 度量标准;[数学]度量;诗体;韵文;诗韵</p>
</blockquote>
<h2 id="78、指标监控-常使用的端点及开启与禁用"><a href="#78、指标监控-常使用的端点及开启与禁用" class="headerlink" title="78、指标监控-常使用的端点及开启与禁用"></a>78、指标监控-常使用的端点及开启与禁用</h2><h3 id="常使用的端点"><a href="#常使用的端点" class="headerlink" title="常使用的端点"></a>常使用的端点</h3><table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>暴露当前应用程序的审核事件信息。需要一个<code>AuditEventRepository组件</code>。</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有Spring Bean的完整列表。</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>暴露可用的缓存。</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有<code>@ConfigurationProperties</code>。</td>
</tr>
<tr>
<td><code>env</code></td>
<td>暴露Spring的属性<code>ConfigurableEnvironment</code></td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已应用的所有Flyway数据库迁移。 需要一个或多个<code>Flyway</code>组件。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个<code>HttpTraceRepository</code>组件。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示应用程序信息。</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示Spring <code>integrationgraph</code> 。需要依赖<code>spring-integration-core</code>。</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中日志的配置。</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有Liquibase数据库迁移。需要一个或多个<code>Liquibase</code>组件。</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的“指标”信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有<code>@RequestMapping</code>路径列表。</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>使应用程序正常关闭。默认禁用。</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>显示由<code>ApplicationStartup</code>收集的启动步骤数据。需要使用<code>SpringApplication</code>进行配置<code>BufferingApplicationStartup</code>。</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储。</td>
</tr>
</tbody></table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>heapdump</code></td>
<td>返回<code>hprof</code>堆转储文件。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖<code>jolokia-core</code>。</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置<code>logging.file.name</code>或<code>logging.file.path</code>属性）。支持使用HTTP<code>Range</code>标头来检索部分日志文件的内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以Prometheus服务器可以抓取的格式公开指标。需要依赖<code>micrometer-registry-prometheus</code>。</td>
</tr>
</tbody></table>
<p>其中最常用的Endpoint：</p>
<ul>
<li><strong>Health：监控状况</strong></li>
<li><strong>Metrics：运行时指标</strong></li>
<li><strong>Loggers：日志记录</strong></li>
</ul>
<h3 id="Health-Endpoint"><a href="#Health-Endpoint" class="headerlink" title="Health Endpoint"></a>Health Endpoint</h3><p>健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。</p>
<p>重要的几点：</p>
<ul>
<li>health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告。</li>
<li>很多的健康检查默认已经自动配置好了，比如：数据库、redis等。</li>
<li>可以很容易的添加自定义的健康检查机制。</li>
</ul>
<h3 id="Metrics-Endpoint"><a href="#Metrics-Endpoint" class="headerlink" title="Metrics Endpoint"></a>Metrics Endpoint</h3><p>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到：</p>
<ul>
<li>通过Metrics对接多种监控系统。</li>
<li>简化核心Metrics开发。</li>
<li>添加自定义Metrics或者扩展已有Metrics。</li>
</ul>
<h3 id="开启与禁用Endpoints"><a href="#开启与禁用Endpoints" class="headerlink" title="开启与禁用Endpoints"></a>开启与禁用Endpoints</h3><ul>
<li>默认所有的Endpoint除过shutdown都是开启的。</li>
<li>需要开启或者禁用某个Endpoint。配置模式为<code>management.endpoint.&lt;endpointName&gt;.enabled = true</code></li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:
  endpoint:
    beans:
      enabled: true</code></pre>

<ul>
<li>或者禁用所有的Endpoint然后手动开启指定的Endpoint。</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:
  endpoints:
    enabled-by-default: false
  endpoint:
    beans:
      enabled: true
    health:
      enabled: true</code></pre>



<h3 id="暴露Endpoints"><a href="#暴露Endpoints" class="headerlink" title="暴露Endpoints"></a>暴露Endpoints</h3><p>支持的暴露方式</p>
<ul>
<li>HTTP：默认只暴露health和info。</li>
<li>JMX：默认暴露所有Endpoint。</li>
<li>除过health和info，剩下的Endpoint都应该进行保护访问。如果引入Spring Security，则会默认配置安全访问规则。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">JMX</th>
<th align="left">Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auditevents</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>beans</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>caches</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>conditions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>configprops</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>env</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>flyway</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>health</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>heapdump</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>httptrace</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>integrationgraph</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>jolokia</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>logfile</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>loggers</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>liquibase</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>metrics</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>mappings</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>prometheus</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>scheduledtasks</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>sessions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>shutdown</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>startup</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>threaddump</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<p>若要更改公开的Endpoint，请配置以下的包含和排除属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.jmx.exposure.include</code></td>
<td align="left"><code>*</code></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.include</code></td>
<td align="left"><code>info, health</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints">官方文档 - Exposing Endpoints</a></p>
<h2 id="79、指标监控-定制Endpoint"><a href="#79、指标监控-定制Endpoint" class="headerlink" title="79、指标监控-定制Endpoint"></a>79、指标监控-定制Endpoint</h2><h3 id="定制-Health-信息"><a href="#定制-Health-信息" class="headerlink" title="定制 Health 信息"></a>定制 Health 信息</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">management:
    health:
      enabled: true
      show-details: always #总是显示详细信息。可显示每个模块的状态信息</code></pre>

<p>通过实现<code>HealthIndicator </code>接口，或继承<code>MyComHealthIndicator </code>类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealthIndicator implements HealthIndicator &#123;

    @Override
    public Health health() &#123;
        int errorCode &#x3D; check(); &#x2F;&#x2F; perform some specific health check
        if (errorCode !&#x3D; 0) &#123;
            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();
        &#125;
        return Health.up().build();
    &#125;

&#125;

&#x2F;*
构建Health
Health build &#x3D; Health.down()
                .withDetail(&quot;msg&quot;, &quot;error service&quot;)
                .withDetail(&quot;code&quot;, &quot;500&quot;)
                .withException(new RuntimeException())
                .build();
*&#x2F;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
public class MyComHealthIndicator extends AbstractHealthIndicator &#123;

    &#x2F;**
     * 真实的检查方法
     * @param builder
     * @throws Exception
     *&#x2F;
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;
        &#x2F;&#x2F;mongodb。  获取连接进行测试
        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F; 检查完成
        if(1 &#x3D;&#x3D; 2)&#123;
&#x2F;&#x2F;            builder.up(); &#x2F;&#x2F;健康
            builder.status(Status.UP);
            map.put(&quot;count&quot;,1);
            map.put(&quot;ms&quot;,100);
        &#125;else &#123;
&#x2F;&#x2F;            builder.down();
            builder.status(Status.OUT_OF_SERVICE);
            map.put(&quot;err&quot;,&quot;连接超时&quot;);
            map.put(&quot;ms&quot;,3000);
        &#125;


        builder.withDetail(&quot;code&quot;,100)
                .withDetails(map);

    &#125;
&#125;</code></pre>



<h3 id="定制info信息"><a href="#定制info信息" class="headerlink" title="定制info信息"></a>定制info信息</h3><p>常用两种方式：</p>
<ul>
<li>编写配置文件</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">info:
  appName: boot-admin
  version: 2.0.1
  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值
  mavenProjectVersion: @project.version@</code></pre>

<ul>
<li>编写InfoContributor</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Collections;

import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;

@Component
public class ExampleInfoContributor implements InfoContributor &#123;

    @Override
    public void contribute(Info.Builder builder) &#123;
        builder.withDetail(&quot;example&quot;,
                Collections.singletonMap(&quot;key&quot;, &quot;value&quot;));
    &#125;

&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/info">http://localhost:8080/actuator/info</a> 会输出以上方式返回的所有info信息</p>
<h3 id="定制Metrics信息"><a href="#定制Metrics信息" class="headerlink" title="定制Metrics信息"></a>定制Metrics信息</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready-metrics-meter">Spring Boot支持的metrics</a></p>
<p>增加定制Metrics：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyService&#123;
    Counter counter;
    public MyService(MeterRegistry meterRegistry)&#123;
         counter &#x3D; meterRegistry.counter(&quot;myservice.method.running.counter&quot;);
    &#125;

    public void hello() &#123;
        counter.increment();
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;也可以使用下面的方式
@Bean
MeterBinder queueSize(Queue queue) &#123;
    return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);
&#125;</code></pre>



<h3 id="定制Endpoint"><a href="#定制Endpoint" class="headerlink" title="定制Endpoint"></a>定制Endpoint</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
@Endpoint(id &#x3D; &quot;container&quot;)
public class DockerEndpoint &#123;

    @ReadOperation
    public Map getDockerInfo()&#123;
        return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;);
    &#125;

    @WriteOperation
    private void restartDocker()&#123;
        System.out.println(&quot;docker restarted....&quot;);
    &#125;

&#125;</code></pre>

<p>场景：</p>
<ul>
<li>开发ReadinessEndpoint来管理程序是否就绪。</li>
<li>开发LivenessEndpoint来管理程序是否存活。</li>
</ul>
<h2 id="80、指标监控-Boot-Admin-Server"><a href="#80、指标监控-Boot-Admin-Server" class="headerlink" title="80、指标监控-Boot Admin Server"></a>80、指标监控-Boot Admin Server</h2><p><a href="">官方Github</a></p>
<p><a target="_blank" rel="noopener" href="https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started">官方文档</a></p>
<p>可视化指标监控</p>
<blockquote>
<p>What is Spring Boot Admin?</p>
<p>codecentric’s Spring Boot Admin is a community project to manage and monitor your <a target="_blank" rel="noopener" href="http://projects.spring.io/spring-boot/">Spring Boot</a> ® applications. The applications register with our Spring Boot Admin Client (via HTTP) or are discovered using Spring Cloud ® (e.g. Eureka, Consul). The UI is just a Vue.js application on top of the Spring Boot Actuator endpoints.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started">开始使用方法</a></p>
<h2 id="81、高级特性-Profile环境切换"><a href="#81、高级特性-Profile环境切换" class="headerlink" title="81、高级特性-Profile环境切换"></a>81、高级特性-Profile环境切换</h2><p>为了方便多环境适配，Spring Boot简化了profile功能。</p>
<ul>
<li>默认配置文件<code>application.yaml</code>任何时候都会加载。</li>
<li>指定环境配置文件<code>application-&#123;env&#125;.yaml</code>，<code>env</code>通常替代为<code>test</code>，</li>
<li>激活指定环境<ul>
<li>配置文件激活：<code>spring.profiles.active=prod</code></li>
<li>命令行激活：<code>java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha</code>（修改配置文件的任意值，<strong>命令行优先</strong>）</li>
</ul>
</li>
<li>默认配置与环境配置同时生效</li>
<li>同名配置项，profile配置优先</li>
</ul>
<h3 id="Profile条件装配功能"><a href="#Profile条件装配功能" class="headerlink" title="@Profile条件装配功能"></a>@Profile条件装配功能</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data
@Component
@ConfigurationProperties(&quot;person&quot;)&#x2F;&#x2F;在配置文件中配置
public class Person&#123;
    private String name;
    private Integer age;
&#125;</code></pre>

<p>application.properties</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">person: 
  name: lun
  age: 8</code></pre>

<hr>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Person &#123;

   String getName();
   Integer getAge();

&#125;

@Profile(&quot;test&quot;)&#x2F;&#x2F;加载application-test.yaml里的
@Component
@ConfigurationProperties(&quot;person&quot;)
@Data
public class Worker implements Person &#123;

    private String name;
    private Integer age;
&#125;

@Profile(value &#x3D; &#123;&quot;prod&quot;,&quot;default&quot;&#125;)&#x2F;&#x2F;加载application-prod.yaml里的
@Component
@ConfigurationProperties(&quot;person&quot;)
@Data
public class Boss implements Person &#123;

    private String name;
    private Integer age;
&#125;</code></pre>



<p>application-test.yaml</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">person:
  name: test-张三

server:
  port: 7000</code></pre>



<p>application-prod.yaml</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">person:
  name: prod-张三

server:
  port: 8000</code></pre>



<p>application.properties</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 激活prod配置文件
spring.profiles.active&#x3D;prod</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowired
private Person person;

@GetMapping(&quot;&#x2F;&quot;)
public String hello()&#123;
    &#x2F;&#x2F;激活了prod，则返回Boss；激活了test，则返回Worker
    return person.getClass().toString();
&#125;</code></pre>

<hr>
<p>@Profile还可以修饰在方法上：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Color &#123;
&#125;

@Configuration
public class MyConfig &#123;

    @Profile(&quot;prod&quot;)
    @Bean
    public Color red()&#123;
        return new Color();
    &#125;

    @Profile(&quot;test&quot;)
    @Bean
    public Color green()&#123;
        return new Color();
    &#125;
&#125;</code></pre>

<hr>
<p>可以激活一组：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.profiles.active&#x3D;production

spring.profiles.group.production[0]&#x3D;proddb
spring.profiles.group.production[1]&#x3D;prodmq</code></pre>



<h2 id="82、高级特性-配置加载优先级"><a href="#82、高级特性-配置加载优先级" class="headerlink" title="82、高级特性-配置加载优先级"></a>82、高级特性-配置加载优先级</h2><h3 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-external-config">官方文档 - Externalized Configuration</a></p>
<p>Spring Boot uses a very particular <code>PropertySource</code> order that is designed to allow sensible overriding of values. Properties are considered in the following order (with values from lower items overriding earlier ones)（1优先级最低，14优先级最高）:</p>
<ol>
<li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.3/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</li>
<li>Config data (such as <code>application.properties</code> files)</li>
<li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li>
<li>OS environment variables.</li>
<li>Java System properties (<code>System.getProperties()</code>).</li>
<li>JNDI attributes from <code>java:comp/env</code>.</li>
<li><code>ServletContext</code> init parameters.</li>
<li><code>ServletConfig</code> init parameters.</li>
<li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li><code>properties</code> attribute on your tests. Available on <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a> and the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">test annotations for testing a particular slice of your application</a>.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.3/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> annotations on your tests.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#using-boot-devtools-globalsettings">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean &#123;

    @Value(&quot;$&#123;name&#125;&quot;)&#x2F;&#x2F;以这种方式可以获得配置值
    private String name;

    &#x2F;&#x2F; ...

&#125;</code></pre>

<hr>
<ul>
<li>外部配置源<ul>
<li>Java属性文件。</li>
<li>YAML文件。</li>
<li>环境变量。</li>
<li>命令行参数。</li>
</ul>
</li>
<li>配置文件查找位置<ol>
<li>classpath 根路径。</li>
<li>classpath 根路径下config目录。</li>
<li>jar包当前目录。</li>
<li>jar包当前目录的config目录。</li>
<li>&#x2F;config子目录的直接子目录。</li>
</ol>
</li>
<li>配置文件加载顺序：<ol>
<li>当前jar包内部的<code>application.properties</code>和<code>application.yml</code>。</li>
<li>当前jar包内部的<code>application-&#123;profile&#125;.properties</code> 和 <code>application-&#123;profile&#125;.yml</code>。</li>
<li>引用的外部jar包的<code>application.properties</code>和<code>application.yml</code>。</li>
<li>引用的外部jar包的<code>application-&#123;profile&#125;.properties</code>和<code>application-&#123;profile&#125;.yml</code>。</li>
</ol>
</li>
<li>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项。</li>
</ul>
<h2 id="83、高级特性-自定义starter细节"><a href="#83、高级特性-自定义starter细节" class="headerlink" title="83、高级特性-自定义starter细节"></a>83、高级特性-自定义starter细节</h2><h3 id="starter启动原理"><a href="#starter启动原理" class="headerlink" title="starter启动原理"></a>starter启动原理</h3><ul>
<li>starter的pom.xml引入autoconfigure依赖</li>
</ul>
<pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR
A[starter] --&gt;B[autoconfigure]
B --&gt; C[spring-boot-starter]
</code></pre>

<ul>
<li><p>autoconfigure包中配置使用<code>META-INF/spring.factories</code>中<code>EnableAutoConfiguration</code>的值，使得项目启动加载指定的自动配置类</p>
</li>
<li><p>编写自动配置类 <code>xxxAutoConfiguration</code> -&gt; <code>xxxxProperties</code></p>
</li>
<li><ul>
<li><code>@Configuration</code></li>
<li><code>@Conditional</code></li>
<li><code>@EnableConfigurationProperties</code></li>
<li><code>@Bean</code></li>
<li>……</li>
</ul>
</li>
<li><p>引入starter — <code>xxxAutoConfiguration</code> — 容器中放入组件 —- <code>绑定xxxProperties</code> —- 配置项</p>
</li>
</ul>
<h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><ul>
<li><p>目标：创建<code>HelloService</code>的自定义starter。</p>
</li>
<li><p>创建两个工程，分别命名为<code>hello-spring-boot-starter</code>（普通Maven工程），<code>hello-spring-boot-starter-autoconfigure</code>（需用用到Spring Initializr创建的Maven工程）。</p>
</li>
<li><p><code>hello-spring-boot-starter</code>无需编写什么代码，只需让该工程引入<code>hello-spring-boot-starter-autoconfigure</code>依赖：</p>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;
         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;

    &lt;groupId&gt;com.lun&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;hello-spring-boot-starter&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.lun&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
    &lt;&#x2F;dependencies&gt;

&lt;&#x2F;project&gt;</code></pre>

<ul>
<li><code>hello-spring-boot-starter-autoconfigure</code>的pom.xml如下：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
		&lt;version&gt;2.4.2&lt;&#x2F;version&gt;
		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;&#x2F;parent&gt;
	&lt;groupId&gt;com.lun&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;&#x2F;artifactId&gt;
	&lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;
	&lt;name&gt;hello-spring-boot-starter-autoconfigure&lt;&#x2F;name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;
	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;
	&lt;&#x2F;properties&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;dependency&gt;
	&lt;&#x2F;dependencies&gt;
&lt;&#x2F;project&gt;</code></pre>

<ul>
<li>创建4个文件：<ul>
<li><code>com/lun/hello/auto/HelloServiceAutoConfiguration</code></li>
<li><code>com/lun/hello/bean/HelloProperties</code></li>
<li><code>com/lun/hello/service/HelloService</code></li>
<li><code>src/main/resources/META-INF/spring.factories</code></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.hello.bean.HelloProperties;
import com.lun.hello.service.HelloService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnMissingBean(HelloService.class)
@EnableConfigurationProperties(HelloProperties.class)&#x2F;&#x2F;默认HelloProperties放在容器中
public class HelloServiceAutoConfiguration &#123;

    @Bean
    public HelloService helloService()&#123;
        return new HelloService();
    &#125;

&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(&quot;hello&quot;)
public class HelloProperties &#123;
    private String prefix;
    private String suffix;

    public String getPrefix() &#123;
        return prefix;
    &#125;

    public void setPrefix(String prefix) &#123;
        this.prefix &#x3D; prefix;
    &#125;

    public String getSuffix() &#123;
        return suffix;
    &#125;

    public void setSuffix(String suffix) &#123;
        this.suffix &#x3D; suffix;
    &#125;
&#125;
</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.hello.bean.HelloProperties;
import org.springframework.beans.factory.annotation.Autowired;


&#x2F;**
 * 默认不要放在容器中
 *&#x2F;
public class HelloService &#123;

    @Autowired
    private HelloProperties helloProperties;

    public String sayHello(String userName)&#123;
        return helloProperties.getPrefix() + &quot;: &quot; + userName + &quot; &gt; &quot; + helloProperties.getSuffix();
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\
com.lun.hello.auto.HelloServiceAutoConfiguration</code></pre>

<ul>
<li><p>用maven插件，将两工程install到本地。</p>
</li>
<li><p>接下来，测试使用自定义starter，用Spring Initializr创建名为<code>hello-spring-boot-starter-test</code>工程，引入<code>hello-spring-boot-starter</code>依赖，其pom.xml如下：</p>
</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
        &lt;version&gt;2.4.2&lt;&#x2F;version&gt;
        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;&#x2F;parent&gt;
    &lt;groupId&gt;com.lun&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;hello-spring-boot-starter-test&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;
    &lt;name&gt;hello-spring-boot-starter-test&lt;&#x2F;name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;
    &lt;&#x2F;properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;
            &lt;scope&gt;test&lt;&#x2F;scope&gt;
        &lt;&#x2F;dependency&gt;

        &lt;!-- 引入&#96;hello-spring-boot-starter&#96;依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.lun&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;hello-spring-boot-starter&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

    &lt;&#x2F;dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;
            &lt;&#x2F;plugin&gt;
        &lt;&#x2F;plugins&gt;
    &lt;&#x2F;build&gt;

&lt;&#x2F;project&gt;
</code></pre>

<ul>
<li>添加配置文件<code>application.properties</code>：</li>
</ul>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">hello.prefix&#x3D;hello
hello.suffix&#x3D;666</code></pre>

<ul>
<li>添加单元测试类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.lun.hello.service.HelloService;&#x2F;&#x2F;来自自定义starter
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloSpringBootStarterTestApplicationTests &#123;

    @Autowired
    private HelloService helloService;

    @Test
    void contextLoads() &#123;
        &#x2F;&#x2F; System.out.println(helloService.sayHello(&quot;lun&quot;));
        Assertions.assertEquals(&quot;hello: lun &gt; 666&quot;, helloService.sayHello(&quot;lun&quot;));
    &#125;

&#125;</code></pre>



<h2 id="84、原理解析-SpringApplication创建初始化流程"><a href="#84、原理解析-SpringApplication创建初始化流程" class="headerlink" title="84、原理解析-SpringApplication创建初始化流程"></a>84、原理解析-SpringApplication创建初始化流程</h2><h3 id="SpringBoot启动过程"><a href="#SpringBoot启动过程" class="headerlink" title="SpringBoot启动过程"></a>SpringBoot启动过程</h3><p>Spring Boot应用的启动类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloSpringBootStarterTestApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(HelloSpringBootStarterTestApplication.class, args);
    &#125;

&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SpringApplication &#123;
    
    ...
    
	public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;
		return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);
	&#125;
    
    public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;
		return new SpringApplication(primarySources).run(args);
	&#125;
    
    &#x2F;&#x2F;先看看new SpringApplication(primarySources)，下一节再看看run()
	public SpringApplication(Class&lt;?&gt;... primarySources) &#123;
		this(null, primarySources);
	&#125;
    
    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;
		this.resourceLoader &#x3D; resourceLoader;
		Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
		this.primarySources &#x3D; new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
        &#x2F;&#x2F;WebApplicationType是枚举类，有NONE,SERVLET,REACTIVE,下行webApplicationType是SERVLET
		this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();
        
        &#x2F;&#x2F;初始启动引导器，去spring.factories文件中找org.springframework.boot.Bootstrapper，但我找不到实现Bootstrapper接口的类
		this.bootstrappers &#x3D; new ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));
		
        &#x2F;&#x2F;去spring.factories找 ApplicationContextInitializer
        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		
        &#x2F;&#x2F;去spring.factories找 ApplicationListener
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));

        this.mainApplicationClass &#x3D; deduceMainApplicationClass();
	&#125;
 	
    private Class&lt;?&gt; deduceMainApplicationClass() &#123;
		try &#123;
			StackTraceElement[] stackTrace &#x3D; new RuntimeException().getStackTrace();
			for (StackTraceElement stackTraceElement : stackTrace) &#123;
				if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;
					return Class.forName(stackTraceElement.getClassName());
				&#125;
			&#125;
		&#125;
		catch (ClassNotFoundException ex) &#123;
			&#x2F;&#x2F; Swallow and continue
		&#125;
		return null;
	&#125;
    
    ...
    
&#125;</code></pre>



<p>spring.factories：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">...

# Application Context Initializers
org.springframework.context.ApplicationContextInitializer&#x3D;\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer

# Application Listeners
org.springframework.context.ApplicationListener&#x3D;\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.env.EnvironmentPostProcessorApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener

...
</code></pre>



<h2 id="85、原理解析-SpringBoot完整启动过程"><a href="#85、原理解析-SpringBoot完整启动过程" class="headerlink" title="85、原理解析-SpringBoot完整启动过程"></a>85、原理解析-SpringBoot完整启动过程</h2><p>继续上一节，接着讨论<code>return new SpringApplication(primarySources).run(args)</code>的<code>run</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SpringApplication &#123;
    
    ...
    
	public ConfigurableApplicationContext run(String... args) &#123;
		StopWatch stopWatch &#x3D; new StopWatch();&#x2F;&#x2F;开始计时器
		stopWatch.start();&#x2F;&#x2F;开始计时
        
        &#x2F;&#x2F;1.
        &#x2F;&#x2F;创建引导上下文（Context环境）createBootstrapContext()
        &#x2F;&#x2F;获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置
		DefaultBootstrapContext bootstrapContext &#x3D; createBootstrapContext();
		
        &#x2F;&#x2F;2.到最后该方法会返回这context
        ConfigurableApplicationContext context &#x3D; null;
		
        &#x2F;&#x2F;3.让当前应用进入headless模式
        configureHeadlessProperty();
        
        &#x2F;&#x2F;4.获取所有 RunListener（运行监听器）,为了方便所有Listener进行事件感知
		SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);
		
        &#x2F;&#x2F;5. 遍历 SpringApplicationRunListener 调用 starting 方法；
		&#x2F;&#x2F; 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。
        listeners.starting(bootstrapContext, this.mainApplicationClass);
		try &#123;
            &#x2F;&#x2F;6.保存命令行参数 ApplicationArguments
			ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);
			
            &#x2F;&#x2F;7.准备环境
            ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners, bootstrapContext, applicationArguments);
			configureIgnoreBeanInfo(environment);
			
            &#x2F;*打印标志
              .   ____          _            __ _ _
             &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
            ( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \
             \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )
              &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F;
             &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F;
             :: Spring Boot ::                (v2.4.2)
            *&#x2F;
            Banner printedBanner &#x3D; printBanner(environment);
            
            &#x2F;&#x2F; 创建IOC容器（createApplicationContext（））
			&#x2F;&#x2F; 根据项目类型webApplicationType（NONE,SERVLET,REACTIVE）创建容器，
			&#x2F;&#x2F; 当前会创建 AnnotationConfigServletWebServerApplicationContext
			context &#x3D; createApplicationContext();
			context.setApplicationStartup(this.applicationStartup);
            
            &#x2F;&#x2F;8.准备ApplicationContext IOC容器的基本信息
			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
			&#x2F;&#x2F;9.刷新IOC容器,创建容器中的所有组件,Spring框架的内容
            refreshContext(context);
			&#x2F;&#x2F;该方法没内容，大概为将来填入
			afterRefresh(context, applicationArguments);
			stopWatch.stop();&#x2F;&#x2F;停止计时
			if (this.logStartupInfo) &#123;&#x2F;&#x2F;this.logStartupInfo默认是true
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			&#125;
            &#x2F;&#x2F;10.
			listeners.started(context);
            
            &#x2F;&#x2F;11.调用所有runners
			callRunners(context, applicationArguments);
		&#125;
		catch (Throwable ex) &#123;
            &#x2F;&#x2F;13.
			handleRunFailure(context, ex, listeners);
			throw new IllegalStateException(ex);
		&#125;

		try &#123;
            &#x2F;&#x2F;12.
			listeners.running(context);
		&#125;
		catch (Throwable ex) &#123;
            &#x2F;&#x2F;13.
			handleRunFailure(context, ex, null);
			throw new IllegalStateException(ex);
		&#125;
		return context;
	&#125;
 
    &#x2F;&#x2F;1. 
    private DefaultBootstrapContext createBootstrapContext() &#123;
		DefaultBootstrapContext bootstrapContext &#x3D; new DefaultBootstrapContext();
		this.bootstrappers.forEach((initializer) -&gt; initializer.intitialize(bootstrapContext));
		return bootstrapContext;
	&#125;
    
    &#x2F;&#x2F;3.
   	private void configureHeadlessProperty() &#123;
        &#x2F;&#x2F;this.headless默认为true
		System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,
				System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));
	&#125;
    
    private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS &#x3D; &quot;java.awt.headless&quot;;
    
    &#x2F;&#x2F;4.
    private SpringApplicationRunListeners getRunListeners(String[] args) &#123;
		Class&lt;?&gt;[] types &#x3D; new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;
		&#x2F;&#x2F;getSpringFactoriesInstances 去 spring.factories 找 SpringApplicationRunListener
        return new SpringApplicationRunListeners(logger,
				getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args),
				this.applicationStartup);
	&#125;
    
    &#x2F;&#x2F;7.准备环境
    private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123;
		&#x2F;&#x2F; Create and configure the environment
        &#x2F;&#x2F;返回或者创建基础环境信息对象，如：StandardServletEnvironment, StandardReactiveWebEnvironment
		ConfigurableEnvironment environment &#x3D; getOrCreateEnvironment();
        &#x2F;&#x2F;配置环境信息对象,读取所有的配置源的配置属性值。
		configureEnvironment(environment, applicationArguments.getSourceArgs());
		&#x2F;&#x2F;绑定环境信息
        ConfigurationPropertySources.attach(environment);
        &#x2F;&#x2F;7.1 通知所有的监听器当前环境准备完成
		listeners.environmentPrepared(bootstrapContext, environment);
		DefaultPropertiesPropertySource.moveToEnd(environment);
		configureAdditionalProfiles(environment);
		bindToSpringApplication(environment);
		if (!this.isCustomEnvironment) &#123;
			environment &#x3D; new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
					deduceEnvironmentClass());
		&#125;
		ConfigurationPropertySources.attach(environment);
		return environment;
	&#125;
    
    &#x2F;&#x2F;8.
    private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,
			ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments, Banner printedBanner) &#123;
		&#x2F;&#x2F;保存环境信息
        context.setEnvironment(environment);
        &#x2F;&#x2F;IOC容器的后置处理流程
		postProcessApplicationContext(context);
        &#x2F;&#x2F;应用初始化器
		applyInitializers(context);
        &#x2F;&#x2F;8.1 遍历所有的 listener 调用 contextPrepared。
        &#x2F;&#x2F;EventPublishRunListenr通知所有的监听器contextPrepared
		listeners.contextPrepared(context);
		bootstrapContext.close(context);
		if (this.logStartupInfo) &#123;
			logStartupInfo(context.getParent() &#x3D;&#x3D; null);
			logStartupProfileInfo(context);
		&#125;
		&#x2F;&#x2F; Add boot specific singleton beans
		ConfigurableListableBeanFactory beanFactory &#x3D; context.getBeanFactory();
		beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
		if (printedBanner !&#x3D; null) &#123;
			beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
		&#125;
		if (beanFactory instanceof DefaultListableBeanFactory) &#123;
			((DefaultListableBeanFactory) beanFactory)
					.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
		&#125;
		if (this.lazyInitialization) &#123;
			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
		&#125;
		&#x2F;&#x2F; Load the sources
		Set&lt;Object&gt; sources &#x3D; getAllSources();
		Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
		load(context, sources.toArray(new Object[0]));
        &#x2F;&#x2F;8.2
		listeners.contextLoaded(context);
	&#125;

    &#x2F;&#x2F;11.调用所有runners
    private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;
		List&lt;Object&gt; runners &#x3D; new ArrayList&lt;&gt;();
        
        &#x2F;&#x2F;获取容器中的 ApplicationRunner
		runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
		&#x2F;&#x2F;获取容器中的  CommandLineRunner
        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
        &#x2F;&#x2F;合并所有runner并且按照@Order进行排序
		AnnotationAwareOrderComparator.sort(runners);
        &#x2F;&#x2F;遍历所有的runner。调用 run 方法
		for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;
			if (runner instanceof ApplicationRunner) &#123;
				callRunner((ApplicationRunner) runner, args);
			&#125;
			if (runner instanceof CommandLineRunner) &#123;
				callRunner((CommandLineRunner) runner, args);
			&#125;
		&#125;
	&#125;
    
    &#x2F;&#x2F;13.
    private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception,
			SpringApplicationRunListeners listeners) &#123;
		try &#123;
			try &#123;
				handleExitCode(context, exception);
				if (listeners !&#x3D; null) &#123;
                    &#x2F;&#x2F;14.
					listeners.failed(context, exception);
				&#125;
			&#125;
			finally &#123;
				reportFailure(getExceptionReporters(context), exception);
				if (context !&#x3D; null) &#123;
					context.close();
				&#125;
			&#125;
		&#125;
		catch (Exception ex) &#123;
			logger.warn(&quot;Unable to close ApplicationContext&quot;, ex);
		&#125;
		ReflectionUtils.rethrowRuntimeException(exception);
	&#125;
    
    ...
&#125;</code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;2. new SpringApplication(primarySources).run(args) 最后返回的接口类型
public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable &#123;
    String CONFIG_LOCATION_DELIMITERS &#x3D; &quot;,; \t\n&quot;;
    String CONVERSION_SERVICE_BEAN_NAME &#x3D; &quot;conversionService&quot;;
    String LOAD_TIME_WEAVER_BEAN_NAME &#x3D; &quot;loadTimeWeaver&quot;;
    String ENVIRONMENT_BEAN_NAME &#x3D; &quot;environment&quot;;
    String SYSTEM_PROPERTIES_BEAN_NAME &#x3D; &quot;systemProperties&quot;;
    String SYSTEM_ENVIRONMENT_BEAN_NAME &#x3D; &quot;systemEnvironment&quot;;
    String APPLICATION_STARTUP_BEAN_NAME &#x3D; &quot;applicationStartup&quot;;
    String SHUTDOWN_HOOK_THREAD_NAME &#x3D; &quot;SpringContextShutdownHook&quot;;

    void setId(String var1);

    void setParent(@Nullable ApplicationContext var1);

    void setEnvironment(ConfigurableEnvironment var1);

    ConfigurableEnvironment getEnvironment();

    void setApplicationStartup(ApplicationStartup var1);

    ApplicationStartup getApplicationStartup();

    void addBeanFactoryPostProcessor(BeanFactoryPostProcessor var1);

    void addApplicationListener(ApplicationListener&lt;?&gt; var1);

    void setClassLoader(ClassLoader var1);

    void addProtocolResolver(ProtocolResolver var1);

    void refresh() throws BeansException, IllegalStateException;

    void registerShutdownHook();

    void close();

    boolean isActive();

    ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;
&#125;</code></pre>

<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#4.
#spring.factories
# Run Listeners
org.springframework.boot.SpringApplicationRunListener&#x3D;\
org.springframework.boot.context.event.EventPublishingRunListener</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">class SpringApplicationRunListeners &#123;

	private final Log log;

	private final List&lt;SpringApplicationRunListener&gt; listeners;

	private final ApplicationStartup applicationStartup;

	SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners,
			ApplicationStartup applicationStartup) &#123;
		this.log &#x3D; log;
		this.listeners &#x3D; new ArrayList&lt;&gt;(listeners);
		this.applicationStartup &#x3D; applicationStartup;
	&#125;

    &#x2F;&#x2F;5.遍历 SpringApplicationRunListener 调用 starting 方法；
	&#x2F;&#x2F;相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。
	void starting(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass) &#123;
		doWithListeners(&quot;spring.boot.application.starting&quot;, (listener) -&gt; listener.starting(bootstrapContext),
				(step) -&gt; &#123;
					if (mainApplicationClass !&#x3D; null) &#123;
						step.tag(&quot;mainApplicationClass&quot;, mainApplicationClass.getName());
					&#125;
				&#125;);
	&#125;
    
    &#x2F;&#x2F;7.1
    void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;
		doWithListeners(&quot;spring.boot.application.environment-prepared&quot;,
				(listener) -&gt; listener.environmentPrepared(bootstrapContext, environment));
	&#125;
    
    &#x2F;&#x2F;8.1
    void contextPrepared(ConfigurableApplicationContext context) &#123;
		doWithListeners(&quot;spring.boot.application.context-prepared&quot;, (listener) -&gt; listener.contextPrepared(context));
	&#125;
    
    &#x2F;&#x2F;8.2
    void contextLoaded(ConfigurableApplicationContext context) &#123;
		doWithListeners(&quot;spring.boot.application.context-loaded&quot;, (listener) -&gt; listener.contextLoaded(context));
	&#125;
    
    &#x2F;&#x2F;10.
    void started(ConfigurableApplicationContext context) &#123;
		doWithListeners(&quot;spring.boot.application.started&quot;, (listener) -&gt; listener.started(context));
	&#125;
    
    &#x2F;&#x2F;12.
    void running(ConfigurableApplicationContext context) &#123;
		doWithListeners(&quot;spring.boot.application.running&quot;, (listener) -&gt; listener.running(context));
	&#125;
    
    &#x2F;&#x2F;14.
    void failed(ConfigurableApplicationContext context, Throwable exception) &#123;
		doWithListeners(&quot;spring.boot.application.failed&quot;,
				(listener) -&gt; callFailedListener(listener, context, exception), (step) -&gt; &#123;
					step.tag(&quot;exception&quot;, exception.getClass().toString());
					step.tag(&quot;message&quot;, exception.getMessage());
				&#125;);
	&#125;
    
    private void doWithListeners(String stepName, Consumer&lt;SpringApplicationRunListener&gt; listenerAction,
			Consumer&lt;StartupStep&gt; stepAction) &#123;
		StartupStep step &#x3D; this.applicationStartup.start(stepName);
		this.listeners.forEach(listenerAction);
		if (stepAction !&#x3D; null) &#123;
			stepAction.accept(step);
		&#125;
		step.end();
	&#125;
    
    ...
    
&#125;</code></pre>



<h2 id="86、原理解析-自定义事件监听组件"><a href="#86、原理解析-自定义事件监听组件" class="headerlink" title="86、原理解析-自定义事件监听组件"></a>86、原理解析-自定义事件监听组件</h2><p><code>MyApplicationContextInitializer.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;

public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) &#123;
        System.out.println(&quot;MyApplicationContextInitializer ....initialize.... &quot;);
    &#125;
&#125;</code></pre>



<p><code>MyApplicationListener.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

public class MyApplicationListener implements ApplicationListener &#123;
    @Override
    public void onApplicationEvent(ApplicationEvent event) &#123;
        System.out.println(&quot;MyApplicationListener.....onApplicationEvent...&quot;);
    &#125;
&#125;</code></pre>



<p><code>MyApplicationRunner.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;


@Order(1)
@Component&#x2F;&#x2F;放入容器
public class MyApplicationRunner implements ApplicationRunner &#123;
    @Override
    public void run(ApplicationArguments args) throws Exception &#123;
        System.out.println(&quot;MyApplicationRunner...run...&quot;);
    &#125;
&#125;</code></pre>



<p><code>MyCommandLineRunner.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
&#x2F;**
 * 应用启动做一个一次性事情
 *&#x2F;
@Order(2)
@Component&#x2F;&#x2F;放入容器
public class MyCommandLineRunner implements CommandLineRunner &#123;
    @Override
    public void run(String... args) throws Exception &#123;
        System.out.println(&quot;MyCommandLineRunner....run....&quot;);
    &#125;
&#125;</code></pre>



<p><code>MySpringApplicationRunListener.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.boot.ConfigurableBootstrapContext;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringApplicationRunListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.env.ConfigurableEnvironment;

public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;

    private SpringApplication application;
    public MySpringApplicationRunListener(SpringApplication application, String[] args)&#123;
        this.application &#x3D; application;
    &#125;

    @Override
    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....starting....&quot;);

    &#125;


    @Override
    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....environmentPrepared....&quot;);
    &#125;


    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....contextPrepared....&quot;);

    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....contextLoaded....&quot;);
    &#125;

    @Override
    public void started(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....started....&quot;);
    &#125;

    @Override
    public void running(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....running....&quot;);
    &#125;

    @Override
    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....failed....&quot;);
    &#125;
&#125;</code></pre>



<p>注册<code>MyApplicationContextInitializer</code>，<code>MyApplicationListener</code>，<code>MySpringApplicationRunListener</code>:</p>
<p><code>resources / META-INF / spring.factories</code>:</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">org.springframework.context.ApplicationContextInitializer&#x3D;\
  com.lun.boot.listener.MyApplicationContextInitializer

org.springframework.context.ApplicationListener&#x3D;\
  com.lun.boot.listener.MyApplicationListener

org.springframework.boot.SpringApplicationRunListener&#x3D;\
  com.lun.boot.listener.MySpringApplicationRunListener</code></pre>



<h2 id="87、后会有期"><a href="#87、后会有期" class="headerlink" title="87、后会有期"></a>87、后会有期</h2><blockquote>
<p>路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<ul>
<li><p>Spring Boot 2 场景整合篇</p>
<ul>
<li>虚拟化技术</li>
<li>安全控制</li>
<li>缓存技术</li>
<li>消息中间件</li>
<li>对象存储</li>
<li>定时调度</li>
<li>异步任务</li>
<li>分布式系统</li>
</ul>
</li>
<li><p>Spring Boot 2 响应式编程</p>
<ul>
<li>响应式编程基础</li>
<li>Webflux开发Web应用</li>
<li>响应式访问持久化层</li>
<li>响应式安全开发</li>
<li>响应式原理</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SpringBoot/">#SpringBoot</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>newpapername</div>
      <div>http://example.com/2022/11/22/newpapername/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>November 22, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
